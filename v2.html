<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>""</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<style>
  :root{
    /* Primary = surfaces. Third = accent. No visible borders by default. */
    --skin-primary:#0e1219;
    --skin-secondary:#2a3144;
    --skin-third:#00d4ff;
    --skin-depth:shadows;
    --skin-panel-bg:var(--skin-primary);
    --skin-panel-bg-bottom:var(--skin-primary);
    --skin-panel-border:rgba(255,255,255,.06);
    --skin-ink:#f4f5fa;
    --skin-muted:#8b94a5;
    --skin-accent:var(--skin-third);
    --skin-accent2:var(--skin-third);
    --skin-button-bg:var(--skin-primary);
    --skin-button-bg2:var(--skin-primary);
    --skin-input-bg:var(--skin-primary);
    --skin-knob-bg:var(--skin-primary);
    --skin-knob-bg2:var(--skin-primary);
    --skin-dial-bg:var(--skin-primary);
    --skin-dial-cap:var(--skin-primary);
    --skin-stage-bg:var(--skin-primary);
    --panel:var(--skin-panel-bg);
    --ink:var(--skin-ink);
    --muted:var(--skin-muted);
    --accent:var(--skin-accent);
    --accent2:var(--skin-accent2);
    --border:var(--skin-panel-border);
  }
  /* Optional: Color blend depth (re-enables darker gradients/mixes) */
  body[data-skin-depth="blend"]{
    --skin-panel-bg-bottom:color-mix(in srgb, var(--skin-primary) 85%, black);
    --skin-button-bg:color-mix(in srgb, var(--skin-primary) 85%, black);
    --skin-button-bg2:color-mix(in srgb, var(--skin-primary) 75%, black);
    --skin-knob-bg2:color-mix(in srgb, var(--skin-primary) 80%, black);
    --skin-dial-cap:color-mix(in srgb, var(--skin-primary) 82%, black);
  }
  body[data-skin-depth="blend"] header,
  body[data-skin-depth="blend"] .rail,
  body[data-skin-depth="blend"] .bottomPanel{
    background:linear-gradient(180deg,var(--skin-panel-bg),var(--skin-panel-bg-bottom));
  }
  body[data-skin-depth="blend"] .stage{
    background:linear-gradient(180deg,var(--skin-stage-bg),color-mix(in srgb, var(--skin-primary) 70%, black));
  }
  body[data-skin-depth="blend"] .knob{
    background:radial-gradient(circle at 35% 35%,var(--skin-knob-bg),var(--skin-knob-bg2));
  }
  body[data-skin-depth="blend"] .dial{
    background:radial-gradient(circle at 35% 35%,var(--skin-dial-bg),var(--skin-dial-cap) 60%);
  }
  body[data-skin-depth="blend"] .cap{
    background:radial-gradient(circle,var(--skin-dial-cap),color-mix(in srgb, var(--skin-primary) 70%, black));
  }
  *{box-sizing:border-box}
  html,body{
    height:100%;
    margin:0;
    background:#0a0a0a;
    color:var(--skin-ink);
    font-family:Inter,system-ui,Segoe UI,Roboto,'Helvetica Neue',Arial;
    overflow:hidden;
  }
  body.performing,
  body.performing *{
    cursor:none !important;
  }
  .app{
    position:relative;
    display:grid;
    grid-template-rows:auto minmax(0,1fr) auto;
    height:100vh;
    width:100vw;
    background:#0a0a0a;
    overflow:hidden;
  }

  body.ui-hidden .app{
    grid-template-rows:minmax(0,1fr);
  }
  body.ui-hidden header,
  body.ui-hidden .rail,
  body.ui-hidden .bottomPanel{
    display:none;
  }
  body.ui-hidden .main{
    grid-template-columns:minmax(0,1fr);
    padding:0;
  }
  body.ui-hidden .stage{
    border-radius:0;
    box-shadow:none;
    border:none;
    max-width:none;
  }
  body.ui-hidden .screen{
    border-radius:0;
    padding:0;
    border:none;
    box-shadow:none;
    width:100%;
    height:100%;
    max-width:100%;
    max-height:100%;
  }
  body.ui-hidden canvas{
    border-radius:0;
  }

  header{
    position:relative;
    z-index:10;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:8px 14px;
    border-bottom:1px solid var(--skin-panel-border);
    background:var(--skin-panel-bg);
    box-shadow:0 2px 8px rgba(0,0,0,.4);
  }
  h1{
    margin:0;
    font-size:14px;
    letter-spacing:.12em;
    text-transform:uppercase;
    opacity:.9;
  }

  .btn{
    padding:8px 14px;
    border-radius:999px;
    border:none;
    background:var(--skin-primary);
    color:var(--skin-ink);
    font-weight:700;
    cursor:pointer;
    font-size:11px;
    letter-spacing:.08em;
    text-transform:uppercase;
    border:1px solid var(--skin-panel-border);
  }
  .btn.alt{
    background:linear-gradient(180deg,var(--skin-button-bg),var(--skin-button-bg2));
    color:var(--skin-ink);
  }
  .btn:active{transform:translateY(1px);}
  .btn:disabled{ opacity:0.5; cursor:not-allowed; }
  .btn.recording{ background:linear-gradient(90deg,#c00,#a00); color:#fff; }
  .headerControls{
    display:flex;
    align-items:center;
    gap:10px;
    flex-wrap:wrap;
  }
  .sourceRow{
    display:flex;
    align-items:center;
    gap:6px;
  }
  .sourceBtn{
    padding:6px 10px;
    border-radius:999px;
    border:1px solid var(--skin-panel-border);
    background:rgba(255,255,255,.04);
    color:var(--skin-muted);
    font-size:10px;
    letter-spacing:.1em;
    text-transform:uppercase;
    cursor:pointer;
  }
  .sourceBtn.on{
    border-color:var(--skin-accent2);
    color:var(--skin-ink);
    background:rgba(124,92,255,.15);
  }
  .sourceBtn:hover:not(.on){ border-color:var(--skin-muted); color:var(--skin-ink); }
  .sourceFilename{
    max-width:120px;
    overflow:hidden;
    text-overflow:ellipsis;
    white-space:nowrap;
    font-size:10px;
    color:var(--skin-muted);
  }
  .recordingIndicator{
    font-size:10px;
    color:#f44;
    letter-spacing:.08em;
    display:none;
  }
  .recordingIndicator.show{ display:inline; }
  input[type="file"]{ display:none; }

  /* Auth */
  .authRow{ display:flex; align-items:center; gap:8px; }
  .authRow .userEmail{ max-width:100px; overflow:hidden; text-overflow:ellipsis; font-size:10px; color:var(--skin-muted); }
  .authOverlay{
    position:fixed; inset:0; background:rgba(0,0,0,.85); display:none; align-items:center; justify-content:center; z-index:40;
  }
  .authOverlay.open{ display:flex; }
  .authBox{
    min-width:280px; padding:20px; border-radius:12px; background:var(--skin-panel-bg);
    border:1px solid var(--skin-panel-border); box-shadow:0 20px 50px rgba(0,0,0,.8);
  }
  .authBox h3{ margin:0 0 14px; font-size:12px; letter-spacing:.1em; text-transform:uppercase; color:var(--skin-muted); }
  .authBox input{ width:100%; padding:10px 12px; margin-bottom:10px; border-radius:8px; border:1px solid var(--skin-panel-border); background:var(--skin-input-bg); color:var(--skin-ink); font-size:12px; box-sizing:border-box; }
  .authBox .authActions{ display:flex; gap:8px; margin-top:14px; flex-wrap:wrap; }
  .authBox .authError{ font-size:11px; color:#e66; margin-top:8px; }

  /* MAIN LAYOUT: rails + stage */
  .main{
    position:relative;z-index:2;
    min-height:0;
    display:grid;
    grid-template-columns:auto minmax(0,1fr) auto;
    column-gap:14px;
    align-items:center;
    justify-items:center;
    padding:8px 10px 4px;
  }

  .rail{
    position:relative;
    z-index:10;
    width:86px;
    min-width:72px;
    max-width:96px;
    height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:8px;
    padding:8px 6px;
    background:var(--skin-panel-bg);
    border-inline:1px solid var(--skin-panel-border);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.04),0 0 40px rgba(0,0,0,.5);
  }
  .rail.left{
    border-radius:12px 0 0 12px;
  }
  .rail.right{
    border-radius:0 12px 12px 0;
  }

  .knob{
    width:100%;
    background:var(--skin-knob-bg);
    border:1px solid var(--skin-panel-border);
    border-radius:10px;
    padding:4px;
    display:flex;
    flex-direction:column;
    align-items:center;
    box-shadow:inset 0 2px 4px rgba(0,0,0,.4),0 4px 14px rgba(0,0,0,.5);
  }
  .knob.active{
    border-color:var(--skin-accent2);
    box-shadow:0 0 0 1px var(--skin-accent2),0 6px 18px rgba(0,0,0,.6);
  }
  .dial{
    width:34px;
    height:34px;
    border-radius:50%;
    background:var(--skin-dial-bg);
    border:4px solid rgba(255,255,255,.06);
    box-shadow:inset 0 4px 12px rgba(0,0,0,.5);
    position:relative;
    cursor:grab;
    transform:rotate(-135deg);
  }
  .dial:active{cursor:grabbing}
  .cap{
    position:absolute;
    inset:7px;
    border-radius:50%;
    background:var(--skin-dial-cap);
    box-shadow:inset 0 2px 6px rgba(0,0,0,.4);
  }
  .marker{
    position:absolute;
    top:5px;
    left:50%;
    transform:translateX(-50%);
    width:3px;
    height:13px;
    border-radius:3px;
    background:linear-gradient(180deg,var(--skin-accent),var(--skin-accent2));
  }
  .label{
    margin-top:4px;
    font-size:9px;
    color:var(--skin-muted);
    letter-spacing:.08em;
    text-align:center;
    text-transform:uppercase;
  }
  .label .shortcut{
    display:block;
    margin-top:2px;
    padding:1px 5px;
    border-radius:999px;
    border:1px solid var(--skin-panel-border);
    background:rgba(255,255,255,.02);
    font-size:8px;
    letter-spacing:.16em;
    color:var(--skin-muted);
  }

  .stage{
    position:relative;
    width:100%;
    height:100%;
    max-width:1600px;
    max-height:100%;
    min-height:0;
    background:var(--skin-stage-bg);
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:12px;
    overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.03),0 20px 60px rgba(0,0,0,.6);
  }
  /* Skin-specific frame (secondary) – one per skin */
  .stage-frame{
    display:none;
    position:absolute;
    inset:0;
    z-index:0;
    width:100%;
    height:100%;
    border-radius:12px;
    pointer-events:none;
    color:var(--skin-secondary);
  }
  .stage-frame svg{
    width:100%;
    height:100%;
    display:block;
  }
  body[data-skin="cybersigilism"] .stage-frame.cybersigilism,
  body[data-skin="fantasy"] .stage-frame.fantasy,
  body[data-skin="anime"] .stage-frame.anime,
  body[data-skin="futuristic"] .stage-frame.futuristic,
  body[data-skin="renaissance"] .stage-frame.renaissance{
    display:block;
    color:var(--skin-third);
  }
  .screen{
    position:relative;
    z-index:1;
    height:100%;
    max-height:100%;
    aspect-ratio:16/9;
    width:auto;
    max-width:100%;
    background:#0a0a0a;
    border-radius:10px;
    padding:6px;
    box-shadow:inset 0 14px 45px rgba(0,0,0,.9);
    display:flex;
    align-items:center;
    justify-content:center;
  }
  canvas{
    width:100%;
    height:100%;
    display:block;
    border-radius:10px;
    background:#000;
  }

  /* BOTTOM PANEL */
  .bottomPanel{
    position:relative;
    z-index:5;
    width:100%;
    background:var(--skin-panel-bg);
    border-top:1px solid var(--skin-panel-border);
    padding:4px 10px;
    display:flex;
    align-items:stretch;
    justify-content:space-between;
    gap:10px;
    box-shadow:0 -8px 25px rgba(0,0,0,.6);
  }

  .toggleRow{
    display:flex;
    flex-wrap:nowrap;
    gap:4px;
    align-items:center;
  }

  .toggleBtn{
    padding:4px 8px;
    border-radius:999px;
    border:1px solid var(--skin-panel-border);
    background:var(--skin-primary);
    color:var(--skin-muted);
    font-size:9px;
    letter-spacing:.1em;
    text-transform:uppercase;
    cursor:pointer;
    white-space:nowrap;
    line-height:1.3;
  }
  .toggleBtn .key{
    opacity:.8;
    margin-right:3px;
    font-size:8px;
  }
  .toggleBtn.on{
    background:linear-gradient(90deg,var(--skin-accent),var(--skin-accent2));
    color:#020308;
    border-color:transparent;
    box-shadow:0 0 0 1px rgba(0,0,0,.6),0 0 14px rgba(0,212,255,.45);
  }

  .toggleContainer{
    flex:1;
    display:flex;
    flex-direction:column;
    gap:3px;
    min-width:0;
    overflow:hidden;
    justify-content:center;
  }
  .slidersGroup{
    display:flex;
    gap:6px;
    flex-shrink:0;
    align-items:flex-end;
  }
  .vSlider{
    display:flex;
    flex-direction:column;
    align-items:center;
    gap:2px;
  }
  .vSlider label{
    font-size:7px;
    letter-spacing:.1em;
    text-transform:uppercase;
    color:var(--skin-muted);
  }
  .vRange{
    writing-mode:vertical-lr;
    direction:rtl;
    appearance:slider-vertical;
    width:14px;
    height:60px;
  }
  .bottomRightStack{
    display:flex;
    flex-direction:column;
    gap:4px;
    align-items:flex-end;
    flex-shrink:0;
    justify-content:center;
  }
  .resRow{
    display:flex;
    align-items:center;
    gap:4px;
  }
  .resRow .resLabel{
    font-size:9px;
    letter-spacing:.1em;
    text-transform:uppercase;
    color:var(--skin-muted);
  }

  .bottomRight{
    display:flex;
    justify-content:flex-end;
    align-items:center;
    gap:6px;
  }
  .presetTrigger{
    padding:8px 14px;
    border-radius:999px;
    border:1px solid var(--skin-panel-border);
    background:var(--skin-primary);
    font-size:10px;
    letter-spacing:.14em;
    text-transform:uppercase;
    cursor:pointer;
    color:var(--skin-ink);
  }
  .presetTrigger.iconBtn{
    padding:8px 10px;
    min-width:0;
  }
  .presetTrigger.on{
    background:linear-gradient(90deg,var(--skin-accent),var(--skin-accent2));
    color:#020308;
    border-color:transparent;
    box-shadow:0 0 0 1px rgba(0,0,0,.6),0 0 22px rgba(0,212,255,.55);
  }

  /* PRESET OVERLAY */
  .presetOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.8);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:30;
  }
  .presetOverlay.open{display:flex;}

  .presetPanel{
    min-width:320px;
    max-width:640px;
    padding:18px 20px 16px;
    border-radius:16px;
    background:var(--skin-panel-bg);
    border:1px solid var(--skin-panel-border);
    box-shadow:0 24px 60px rgba(0,0,0,.9);
  }
  .presetHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
  }
  .presetTitle{
    font-size:11px;
    letter-spacing:.16em;
    text-transform:uppercase;
    color:var(--skin-muted);
  }
  .presetGrid{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-top:12px;
  }
  .preset{
    padding:6px 10px;
    border-radius:999px;
    background:rgba(255,255,255,.02);
    border:1px solid var(--skin-panel-border);
    cursor:pointer;
    font-size:11px;
    letter-spacing:.08em;
    text-transform:uppercase;
  }
  .preset:hover{
    border-color:var(--skin-accent2);
  }

  /* SKIN OVERLAY */
  .skinOverlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.8);
    display:none;
    align-items:center;
    justify-content:center;
    z-index:30;
  }
  .skinOverlay.open{ display:flex; }
  .skinPanel{
    min-width:320px;
    max-width:420px;
    padding:18px 20px 20px;
    border-radius:16px;
    background:var(--skin-panel-bg);
    border:1px solid var(--skin-panel-border);
    box-shadow:0 24px 60px rgba(0,0,0,.9);
  }
  .skinPanel .skinPanelHeader{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
    margin-bottom:16px;
  }
  .skinPanel .skinPanelTitle{
    font-size:11px;
    letter-spacing:.16em;
    text-transform:uppercase;
    color:var(--skin-muted);
  }
  .skinGrid{
    display:flex;
    flex-wrap:wrap;
    gap:8px;
    margin-bottom:16px;
  }
  .skinCard{
    padding:10px 14px;
    border-radius:10px;
    background:rgba(255,255,255,.03);
    border:1px solid var(--skin-panel-border);
    cursor:pointer;
    font-size:11px;
    letter-spacing:.08em;
    text-transform:uppercase;
    color:var(--skin-ink);
  }
  .skinCard:hover{ border-color:var(--skin-accent2); }
  .skinCard.active{
    border-color:var(--skin-accent2);
    background:rgba(124,92,255,.12);
    box-shadow:0 0 0 1px var(--skin-accent2);
  }
  .skinColors{
    display:flex;
    align-items:center;
    gap:12px;
    flex-wrap:wrap;
  }
  .skinColorRow{
    display:flex;
    align-items:center;
    gap:8px;
  }
  .skinColorRow label{
    font-size:10px;
    letter-spacing:.1em;
    text-transform:uppercase;
    color:var(--skin-muted);
    min-width:88px;
  }
  .skinColorRow input[type="color"]{
    width:36px;
    height:28px;
    border:1px solid var(--skin-panel-border);
    border-radius:6px;
    padding:2px;
    cursor:pointer;
    background:var(--skin-input-bg);
  }

  /* CUSTOM SKIN EDITOR — draggable floating panel */
  .cse-panel{
    position:fixed;display:none;z-index:55;
    top:50%;left:50%;
    width:380px;max-height:88vh;
    background:rgba(10,10,14,.97);border:1px solid rgba(255,255,255,.1);border-radius:16px;
    backdrop-filter:blur(16px);-webkit-backdrop-filter:blur(16px);
    box-shadow:0 30px 80px rgba(0,0,0,.8),0 0 0 1px rgba(255,255,255,.04);
    overflow-y:auto;overflow-x:hidden;padding:0 20px 20px;
    flex-direction:column;gap:12px;
    font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,sans-serif;
  }
  .cse-panel.open{display:flex;}
  .cse-top-bar{
    display:flex;justify-content:space-between;align-items:center;
    cursor:grab;padding:14px 0 6px;position:sticky;top:0;
    background:rgba(10,10,14,.97);z-index:1;border-radius:16px 16px 0 0;
  }
  .cse-top-bar:active{cursor:grabbing;}
  .cse-title{font-size:11px;letter-spacing:.16em;text-transform:uppercase;color:#8b94a5;}
  .cse-close{
    background:none;border:1px solid rgba(255,255,255,.1);color:#8b94a5;
    padding:4px 10px;border-radius:6px;font-size:9px;cursor:pointer;letter-spacing:.1em;
  }
  .cse-close:hover{border-color:rgba(255,255,255,.3);color:#fff;}
  .cse-section{display:flex;flex-direction:column;gap:6px;}
  .cse-section-label{font-size:9px;letter-spacing:.12em;text-transform:uppercase;color:#8b94a5;}
  .cse-row{display:flex;align-items:center;gap:8px;}
  .cse-row label{font-size:9px;color:#8b94a5;min-width:55px;letter-spacing:.08em;text-transform:uppercase;}
  .cse-row input[type="color"]{
    width:32px;height:24px;border:1px solid rgba(255,255,255,.1);border-radius:6px;padding:2px;cursor:pointer;background:#0e1219;
  }
  .cse-row select,.cse-row input[type="text"]{
    flex:1;padding:5px 8px;border-radius:6px;border:1px solid rgba(255,255,255,.1);
    background:#0a0a0a;color:#f4f5fa;font-size:10px;
  }
  .cse-row input[type="range"]{flex:1;accent-color:#7c5cff;}
  .cse-btn{
    padding:7px 12px;border-radius:8px;border:1px solid rgba(255,255,255,.1);
    background:rgba(255,255,255,.04);color:#f4f5fa;font-size:10px;cursor:pointer;
    letter-spacing:.08em;text-transform:uppercase;text-align:center;transition:all .15s;
  }
  .cse-btn:hover{border-color:rgba(255,255,255,.25);background:rgba(255,255,255,.08);}
  .cse-btn-primary{background:rgba(124,92,255,.2);border-color:rgba(124,92,255,.4);}
  .cse-btn-primary:hover{background:rgba(124,92,255,.35);}
  .cse-btn-danger{border-color:rgba(255,60,60,.3);}
  .cse-btn-danger:hover{background:rgba(255,60,60,.15);border-color:rgba(255,60,60,.5);}
  .cse-layer-list{display:flex;flex-direction:column;gap:4px;max-height:220px;overflow-y:auto;}
  .cse-layer{
    display:grid;grid-template-columns:32px 1fr auto;align-items:start;gap:6px;
    padding:5px 6px;border-radius:8px;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.06);
  }
  .cse-layer.selected{border-color:rgba(124,92,255,.4);background:rgba(124,92,255,.08);}
  .cse-layer img{width:32px;height:32px;object-fit:contain;border-radius:4px;background:#0a0a0a;}
  .cse-layer-info{display:flex;flex-direction:column;gap:3px;min-width:0;}
  .cse-layer-name{font-size:9px;color:#f4f5fa;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
  .cse-layer-controls{display:flex;flex-direction:column;gap:2px;}
  .cse-layer-row{display:flex;align-items:center;gap:3px;}
  .cse-layer-row span{font-size:8px;color:#8b94a5;min-width:22px;}
  .cse-layer-row label{font-size:7px;color:#666;text-transform:uppercase;letter-spacing:.06em;min-width:18px;}
  .cse-layer-row input[type="range"]{flex:1;accent-color:#7c5cff;height:12px;}
  .cse-layer-mode{
    display:flex;gap:2px;
  }
  .cse-layer-mode button{
    flex:1;font-size:7px;padding:2px 4px;border-radius:3px;border:1px solid rgba(255,255,255,.1);
    background:rgba(255,255,255,.03);color:#888;cursor:pointer;text-transform:uppercase;
    letter-spacing:.04em;transition:all .12s;
  }
  .cse-layer-mode button.active{background:rgba(124,92,255,.2);border-color:rgba(124,92,255,.4);color:#c8b8ff;}
  .cse-layer-mode button:hover:not(.active){background:rgba(255,255,255,.06);color:#bbb;}
  .cse-layer-btns{display:flex;flex-direction:column;gap:2px;flex-shrink:0;}
  .cse-layer-btn{
    width:24px;height:20px;border-radius:4px;border:1px solid rgba(255,255,255,.12);
    background:rgba(255,255,255,.04);color:#aab;cursor:pointer;font-size:11px;
    display:flex;align-items:center;justify-content:center;padding:0;line-height:1;
    transition:all .1s;
  }
  .cse-layer-btn:hover{color:#fff;border-color:rgba(255,255,255,.3);background:rgba(255,255,255,.1);}
  .cse-layer-btn[disabled]{opacity:.25;cursor:default;pointer-events:none;}
  .cse-layer-btn.del:hover{color:#ff4444;border-color:rgba(255,60,60,.3);background:rgba(255,60,60,.08);}
  .cse-actions{display:flex;gap:8px;padding-top:8px;border-top:1px solid rgba(255,255,255,.06);}
  .cse-actions .cse-btn{flex:1;}
  .cse-knob-preview{
    width:40px;height:40px;border-radius:50%;border:1px solid rgba(255,255,255,.1);
    background-size:contain;background-position:center;background-repeat:no-repeat;
    background-color:#0a0a0a;
  }

  /* Global PNG + texture background layer (inside = behind panels) */
  .custom-skin-bg{
    position:absolute;inset:0;z-index:0;pointer-events:none;overflow:hidden;
  }
  .custom-skin-bg .cse-img-layer{
    position:absolute;inset:0;pointer-events:none;
  }
  .custom-skin-bg .cse-tex-layer{
    position:absolute;inset:0;pointer-events:none;
    background-repeat:repeat;background-size:256px 256px;
  }
  /* Outside image layer (above panels) */
  .cse-outside-layer{
    position:absolute;inset:0;z-index:25;pointer-events:none;overflow:hidden;
  }
  .cse-outside-layer img,
  .custom-skin-bg img{
    position:absolute;pointer-events:none;transform-origin:center center;
    user-select:none;-webkit-user-drag:none;
  }
  /* During editing: panels pass-through pointer events so inside images can be dragged
     while remaining visually behind (the blended look). Outside layer stays on top. */
  body.cse-editing header,
  body.cse-editing .main,
  body.cse-editing .bottomPanel{
    pointer-events:none;
  }
  body.cse-editing .custom-skin-bg img,
  body.cse-editing .cse-outside-layer img{
    pointer-events:auto;cursor:grab;
  }
  body.cse-editing .custom-skin-bg img.dragging,
  body.cse-editing .cse-outside-layer img.dragging{cursor:grabbing;}
  body.cse-editing .custom-skin-bg img.selected,
  body.cse-editing .cse-outside-layer img.selected{
    outline:2px solid rgba(124,92,255,.8);outline-offset:2px;
  }

  /* When custom skin is active, panels become translucent so PNGs bleed through */
  body[data-skin="custom"] header,
  body[data-skin="custom"] .rail,
  body[data-skin="custom"] .bottomPanel,
  body[data-skin="custom"] .stage{
    background-color:var(--cse-surface,var(--skin-primary));
  }
  body[data-skin="custom"] .knob,
  body[data-skin="custom"] .dial,
  body[data-skin="custom"] .cap{
    background-color:var(--cse-surface,var(--skin-primary));
  }

  .skinCard.cse-create{border-style:dashed;color:#8b94a5;}
  .skinCard.cse-create:hover{border-color:var(--skin-accent2);color:#f4f5fa;}
  .skinCard .skinCardDel{
    margin-left:6px;font-size:10px;color:#8b94a5;cursor:pointer;padding:2px 4px;border-radius:4px;
  }
  .skinCard .skinCardDel:hover{color:#ff4444;background:rgba(255,60,60,.1);}

  /* LIBRARY OVERLAY */
  .libOverlay{
    position:fixed;inset:0;background:rgba(0,0,0,.85);
    display:none;align-items:center;justify-content:center;z-index:35;
  }
  .libOverlay.open{display:flex;}
  .libPanel{
    width:680px;max-width:92vw;max-height:85vh;
    padding:0;border-radius:16px;
    background:var(--skin-panel-bg);
    border:1px solid var(--skin-panel-border);
    box-shadow:0 24px 60px rgba(0,0,0,.9);
    display:flex;flex-direction:column;overflow:hidden;
  }
  .libHeader{
    display:flex;justify-content:space-between;align-items:center;
    padding:14px 18px 10px;border-bottom:1px solid var(--skin-panel-border);
    flex-shrink:0;
  }
  .libTitle{
    font-size:11px;letter-spacing:.16em;text-transform:uppercase;color:var(--skin-muted);
  }
  .libTabs{
    display:flex;gap:4px;
  }
  .libTab{
    padding:6px 14px;border-radius:999px;border:1px solid var(--skin-panel-border);
    background:rgba(255,255,255,.03);color:var(--skin-muted);
    font-size:10px;letter-spacing:.12em;text-transform:uppercase;cursor:pointer;
  }
  .libTab.active{
    background:linear-gradient(90deg,var(--skin-accent),var(--skin-accent2));
    color:#020308;border-color:transparent;
  }
  .libBody{
    flex:1;overflow-y:auto;padding:14px 18px 18px;
  }
  .libCatLabel{
    font-size:9px;letter-spacing:.14em;text-transform:uppercase;
    color:var(--skin-accent);margin:14px 0 8px;
  }
  .libCatLabel:first-child{margin-top:0;}
  .libGrid{
    display:flex;flex-wrap:wrap;gap:6px;
  }
  .libCard{
    padding:7px 12px;border-radius:8px;
    background:rgba(255,255,255,.03);border:1px solid var(--skin-panel-border);
    cursor:pointer;font-size:10px;letter-spacing:.06em;text-transform:uppercase;
    color:var(--skin-ink);transition:all .12s;user-select:none;
  }
  .libCard:hover{border-color:var(--skin-accent2);background:rgba(255,255,255,.06);}
  .libCard.on{
    border-color:var(--skin-accent);background:rgba(124,92,255,.15);
    box-shadow:0 0 0 1px var(--skin-accent);
  }
  .libCard .libCardSub{
    display:block;font-size:8px;color:var(--skin-muted);margin-top:2px;
    letter-spacing:.04em;
  }
  .libSlots{
    margin-top:16px;padding-top:14px;border-top:1px solid var(--skin-panel-border);
  }
  .libSlotsLabel{
    font-size:9px;letter-spacing:.14em;text-transform:uppercase;
    color:var(--skin-muted);margin-bottom:8px;
  }
  .libSlotRow{
    display:flex;gap:4px;flex-wrap:wrap;margin-bottom:6px;
  }
  .libSlotRowLabel{
    font-size:8px;letter-spacing:.1em;text-transform:uppercase;
    color:var(--skin-muted);margin-bottom:3px;
  }
  .libSlot{
    padding:5px 10px;border-radius:6px;
    background:rgba(255,255,255,.04);border:1px solid var(--skin-panel-border);
    font-size:9px;letter-spacing:.06em;text-transform:uppercase;
    cursor:pointer;color:var(--skin-ink);transition:all .12s;
  }
  .libSlot:hover{border-color:var(--skin-accent2);}
  .libSlot.on{
    border-color:#0ff;background:rgba(0,255,255,.12);
    box-shadow:0 0 6px rgba(0,255,255,.2);
  }
  .libEffectCard{
    padding:7px 12px;border-radius:8px;
    background:rgba(255,255,255,.03);border:1px solid var(--skin-panel-border);
    cursor:pointer;font-size:10px;letter-spacing:.06em;text-transform:uppercase;
    color:var(--skin-muted);transition:all .12s;user-select:none;
  }
  .libEffectCard:hover{border-color:var(--skin-accent2);color:var(--skin-ink);}
  .libEffectCard.on{
    border-color:var(--skin-accent);color:var(--skin-ink);
    background:rgba(124,92,255,.15);
  }
  .libEffectCard .libEffKey{
    display:inline-block;margin-right:4px;opacity:.7;font-size:9px;
  }
  .toggleRow.row2{margin-top:2px;}

  /* SKIN: Cybersigilism – obsidian surface, branded sigils, violet bleed */
  body[data-skin="cybersigilism"]{
    --skin-panel-bg:var(--skin-primary);
    --skin-panel-bg-bottom:var(--skin-primary);
    --skin-ink:#c8bfe8;
    --skin-muted:#6b5f8a;
    --skin-accent:var(--skin-third);
    --skin-accent2:var(--skin-third);
    --skin-button-bg:var(--skin-primary);
    --skin-button-bg2:var(--skin-primary);
    --skin-input-bg:var(--skin-primary);
    --skin-knob-bg:var(--skin-primary);
    --skin-knob-bg2:var(--skin-primary);
    --skin-dial-bg:var(--skin-primary);
    --skin-dial-cap:var(--skin-primary);
    --skin-stage-bg:var(--skin-primary);
  }
  body[data-skin="cybersigilism"] header,
  body[data-skin="cybersigilism"] .rail,
  body[data-skin="cybersigilism"] .bottomPanel{
    background:var(--skin-panel-bg);
    box-shadow:inset 0 0 30px rgba(139,0,255,.03),0 2px 10px rgba(0,0,0,.7);
  }
  body[data-skin="cybersigilism"] .stage{
    background:radial-gradient(ellipse at center, #0d0d1a 0%, var(--skin-primary) 70%);
    box-shadow:
      inset 0 0 80px rgba(139,0,255,.06),
      inset 0 0 2px rgba(139,0,255,.2),
      0 0 40px rgba(139,0,255,.03),
      0 20px 60px rgba(0,0,0,.8);
  }
  body[data-skin="cybersigilism"] .stage::before{
    content:'';position:absolute;inset:0;border-radius:12px;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='256' height='256' filter='url(%23n)' opacity='1'/%3E%3C/svg%3E");
    opacity:0.035;mix-blend-mode:overlay;pointer-events:none;z-index:0;
  }
  body[data-skin="cybersigilism"] .stage::after{
    content:'';position:absolute;inset:0;border-radius:12px;
    background:radial-gradient(ellipse at center, transparent 40%, rgba(139,0,255,.06) 100%);
    pointer-events:none;z-index:0;
  }
  body[data-skin="cybersigilism"] .screen{
    box-shadow:inset 0 0 40px rgba(0,0,0,.9),0 0 20px rgba(139,0,255,.07);
  }
  body[data-skin="cybersigilism"] .knob.active{
    box-shadow:0 0 0 1px var(--skin-accent),0 0 18px rgba(139,0,255,.45),0 6px 18px rgba(0,0,0,.6);
  }

  /* SKIN: Fantasy – forged dark iron, bronze patina, enchanted glow */
  body[data-skin="fantasy"]{
    --skin-panel-bg:var(--skin-primary);
    --skin-panel-bg-bottom:var(--skin-primary);
    --skin-ink:#e8e0d0;
    --skin-muted:#8a7d60;
    --skin-accent:var(--skin-third);
    --skin-accent2:var(--skin-third);
    --skin-button-bg:var(--skin-primary);
    --skin-button-bg2:var(--skin-primary);
    --skin-input-bg:var(--skin-primary);
    --skin-knob-bg:var(--skin-primary);
    --skin-knob-bg2:var(--skin-primary);
    --skin-dial-bg:var(--skin-primary);
    --skin-dial-cap:var(--skin-primary);
    --skin-stage-bg:var(--skin-primary);
  }
  body[data-skin="fantasy"] header,
  body[data-skin="fantasy"] .rail,
  body[data-skin="fantasy"] .bottomPanel{
    background:var(--skin-panel-bg);
    box-shadow:inset 0 1px 0 rgba(212,175,55,.08),inset 0 -1px 0 rgba(0,0,0,.25),0 3px 14px rgba(0,0,0,.7);
  }
  body[data-skin="fantasy"] .stage{
    background:
      linear-gradient(135deg, rgba(212,175,55,.015) 0%, transparent 50%, rgba(212,175,55,.015) 100%),
      linear-gradient(180deg, #0e1016 0%, var(--skin-primary) 50%, #0a0c10 100%);
    box-shadow:
      inset 0 2px 6px rgba(212,175,55,.08),
      inset 0 -2px 6px rgba(0,0,0,.35),
      inset 0 0 50px rgba(0,0,0,.4),
      0 6px 35px rgba(0,0,0,.7),
      0 0 1px rgba(212,175,55,.2);
  }
  body[data-skin="fantasy"] .stage::before{
    content:'';position:absolute;inset:0;border-radius:12px;
    background:repeating-linear-gradient(120deg, transparent, transparent 3px, rgba(212,175,55,.006) 3px, rgba(212,175,55,.006) 4px);
    pointer-events:none;z-index:0;
  }
  body[data-skin="fantasy"] .stage::after{
    content:'';position:absolute;inset:0;border-radius:12px;
    background:radial-gradient(ellipse at center, transparent 35%, rgba(212,175,55,.03) 75%, rgba(0,0,0,.18) 100%);
    pointer-events:none;z-index:0;
  }
  body[data-skin="fantasy"] .screen{
    box-shadow:inset 0 0 35px rgba(0,0,0,.9),0 0 10px rgba(212,175,55,.05);
  }
  body[data-skin="fantasy"] .knob.active{
    box-shadow:0 0 0 1px var(--skin-accent),0 0 16px rgba(212,175,55,.35),0 6px 18px rgba(0,0,0,.5);
  }

  /* SKIN: Anime – manga panel, halftone, hard comic shadows */
  body[data-skin="anime"]{
    --skin-panel-bg:var(--skin-primary);
    --skin-panel-bg-bottom:var(--skin-primary);
    --skin-ink:#f0eef5;
    --skin-muted:#8888aa;
    --skin-accent:var(--skin-third);
    --skin-accent2:var(--skin-third);
    --skin-button-bg:var(--skin-primary);
    --skin-button-bg2:var(--skin-primary);
    --skin-input-bg:var(--skin-primary);
    --skin-knob-bg:var(--skin-primary);
    --skin-knob-bg2:var(--skin-primary);
    --skin-dial-bg:var(--skin-primary);
    --skin-dial-cap:var(--skin-primary);
    --skin-stage-bg:var(--skin-primary);
  }
  body[data-skin="anime"] header,
  body[data-skin="anime"] .rail,
  body[data-skin="anime"] .bottomPanel{
    background:var(--skin-panel-bg);
    border:2px solid rgba(255,255,255,.08);
    box-shadow:4px 4px 0 rgba(0,0,0,.4);
  }
  body[data-skin="anime"] .stage{
    background:#0f0f17;
    box-shadow:8px 8px 0 rgba(0,0,0,.35),0 20px 60px rgba(0,0,0,.5);
  }
  body[data-skin="anime"] .stage::before{
    content:'';position:absolute;inset:0;border-radius:10px;
    background:radial-gradient(circle 1.2px at center, rgba(255,234,0,.025) 55%, transparent 55%);
    background-size:10px 10px;
    pointer-events:none;z-index:0;
  }
  body[data-skin="anime"] .screen{
    box-shadow:4px 4px 0 rgba(0,0,0,.5),inset 0 0 20px rgba(0,0,0,.8);
    border:none;
  }
  body[data-skin="anime"] .knob{
    box-shadow:3px 3px 0 rgba(0,0,0,.3);
  }
  body[data-skin="anime"] .knob.active{
    box-shadow:0 0 0 2px var(--skin-accent),3px 3px 0 rgba(0,0,0,.4);
  }
  body[data-skin="anime"] .toggleBtn{
    border-width:2px;
    box-shadow:2px 2px 0 rgba(0,0,0,.3);
  }

  /* SKIN: Futuristic */
  body[data-skin="futuristic"]{
    --skin-panel-bg:var(--skin-primary);
    --skin-panel-bg-bottom:var(--skin-primary);
    --skin-ink:#c0f0d8;
    --skin-muted:#4a8066;
    --skin-accent:var(--skin-third);
    --skin-accent2:var(--skin-third);
    --skin-button-bg:var(--skin-primary);
    --skin-button-bg2:var(--skin-primary);
    --skin-input-bg:var(--skin-primary);
    --skin-knob-bg:var(--skin-primary);
    --skin-knob-bg2:var(--skin-primary);
    --skin-dial-bg:var(--skin-primary);
    --skin-dial-cap:var(--skin-primary);
    --skin-stage-bg:var(--skin-primary);
  }
  body[data-skin="futuristic"] header,
  body[data-skin="futuristic"] .rail,
  body[data-skin="futuristic"] .bottomPanel{
    background:var(--skin-panel-bg);
    box-shadow:inset 0 0 20px rgba(0,255,136,.03),0 2px 10px rgba(0,0,0,.7);
  }
  body[data-skin="futuristic"] .stage{
    background:var(--skin-stage-bg);
    box-shadow:inset 0 0 30px rgba(0,255,136,.04),0 20px 60px rgba(0,0,0,.7);
  }
  body[data-skin="futuristic"] .knob.active{
    box-shadow:0 0 0 1px var(--skin-accent),0 0 18px rgba(0,255,136,.4),0 6px 18px rgba(0,0,0,.6);
  }

  /* SKIN: Renaissance – gilt museum frame, aged canvas, warm patina */
  body[data-skin="renaissance"]{
    --skin-panel-bg:var(--skin-primary);
    --skin-panel-bg-bottom:var(--skin-primary);
    --skin-ink:#e8dcc8;
    --skin-muted:#8a7a5e;
    --skin-accent:var(--skin-third);
    --skin-accent2:var(--skin-third);
    --skin-button-bg:var(--skin-primary);
    --skin-button-bg2:var(--skin-primary);
    --skin-input-bg:var(--skin-primary);
    --skin-knob-bg:var(--skin-primary);
    --skin-knob-bg2:var(--skin-primary);
    --skin-dial-bg:var(--skin-primary);
    --skin-dial-cap:var(--skin-primary);
    --skin-stage-bg:var(--skin-primary);
  }
  body[data-skin="renaissance"] header,
  body[data-skin="renaissance"] .rail,
  body[data-skin="renaissance"] .bottomPanel{
    background:var(--skin-panel-bg);
    box-shadow:inset 0 1px 0 rgba(201,168,76,.1),inset 0 -1px 0 rgba(0,0,0,.25),0 3px 14px rgba(0,0,0,.6);
  }
  body[data-skin="renaissance"] .stage{
    background:linear-gradient(180deg, #14100a 0%, var(--skin-primary) 40%, #100c06 100%);
    box-shadow:
      inset 0 2px 6px rgba(201,168,76,.1),
      inset 0 -2px 6px rgba(0,0,0,.35),
      inset 0 0 60px rgba(0,0,0,.3),
      0 8px 35px rgba(0,0,0,.6),
      0 0 1px rgba(201,168,76,.3);
  }
  body[data-skin="renaissance"] .stage::before{
    content:'';position:absolute;inset:0;border-radius:12px;
    background-image:url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.45' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='200' height='200' filter='url(%23n)' opacity='1'/%3E%3C/svg%3E");
    opacity:0.04;mix-blend-mode:soft-light;pointer-events:none;z-index:0;
  }
  body[data-skin="renaissance"] .stage::after{
    content:'';position:absolute;inset:0;border-radius:12px;
    background:radial-gradient(ellipse at center, transparent 30%, rgba(18,14,8,.4) 100%);
    pointer-events:none;z-index:0;
  }
  body[data-skin="renaissance"] .screen{
    box-shadow:inset 0 0 35px rgba(0,0,0,.85),0 0 8px rgba(201,168,76,.06);
  }
  body[data-skin="renaissance"] .knob.active{
    box-shadow:0 0 0 1px var(--skin-accent),0 0 16px rgba(201,168,76,.35),0 6px 18px rgba(0,0,0,.5);
  }
</style>
</head>
<body>
  <div class="app">
    <div class="custom-skin-bg" id="customSkinBg">
      <div class="cse-img-layer" id="cseImgLayer"></div>
      <div class="cse-tex-layer" id="cseTexLayer"></div>
    </div>
    <div class="cse-outside-layer" id="cseOutsideLayer"></div>
    <header>
      <h1></h1>
      <div class="headerControls">
        <div class="sourceRow">
          <button id="sourceCamera" class="sourceBtn on" type="button">Camera</button>
          <button id="sourceUpload" class="sourceBtn" type="button">Upload</button>
          <input id="fileInput" type="file" accept="video/*" />
          <span id="sourceFilename" class="sourceFilename" aria-hidden="true"></span>
          <button id="sourceClear" class="sourceBtn" type="button" style="display:none;">Clear</button>
        </div>
        <div class="sourceRow">
          <span class="sourceFilename" style="max-width:none;margin-right:4px;">Audio</span>
          <button id="audioNone" class="sourceBtn" type="button" title="No audio">None</button>
          <button id="audioVideo" class="sourceBtn on" type="button" title="Mic or uploaded video audio">Video</button>
        </div>
        <span id="recordingIndicator" class="recordingIndicator">Recording…</span>
        <div id="authRow" class="authRow" style="display:none;">
          <button id="authLoginBtn" class="sourceBtn" type="button">Login</button>
          <span id="authUserEmail" class="userEmail" style="display:none;"></span>
          <button id="authLogoutBtn" class="sourceBtn" type="button" style="display:none;">Log out</button>
        </div>
        <button id="recordBtn" class="btn">● RECORD</button>
        <button id="downloadBtn" class="btn alt" title="Record first to download">DOWNLOAD</button>
      </div>
    </header>
    <div id="authOverlay" class="authOverlay">
      <div class="authBox">
        <h3>Sign in / Sign up</h3>
        <input id="authEmail" type="email" placeholder="Email" autocomplete="email" />
        <input id="authPassword" type="password" placeholder="Password" autocomplete="current-password" />
        <div class="authActions">
          <button id="authSignIn" class="btn">Sign in</button>
          <button id="authSignUp" class="btn alt">Sign up</button>
          <button id="authOverlayClose" class="sourceBtn" type="button">Cancel</button>
        </div>
        <div id="authError" class="authError"></div>
      </div>
    </div>

    <div class="main">
      <!-- LEFT RAIL (dynamically populated) -->
      <aside class="rail left" id="railLeft"></aside>

      <!-- STAGE -->
      <div class="stage" id="stage">
        <!-- CYBERSIGILISM: obsidian surface, branded sigils, organic thorns, violet bleed -->
        <div class="stage-frame cybersigilism" aria-hidden="true">
          <svg viewBox="0 0 400 240" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <filter id="csGlow"><feGaussianBlur stdDeviation="1.8" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
              <filter id="csDeep"><feGaussianBlur stdDeviation="3" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter>
            </defs>
            <g fill="none" stroke="currentColor" stroke-linecap="round">
              <!-- Deep glow layer (thicker, blurred) -->
              <g filter="url(#csDeep)" opacity="0.3" stroke-width="3">
                <path d="M20,18 C60,4 100,28 140,10 C180,0 220,22 260,8 C300,0 340,18 380,12"/>
                <path d="M20,222 C60,236 100,212 140,230 C180,240 220,218 260,232 C300,240 340,222 380,228"/>
                <path d="M18,20 C4,60 28,100 10,140 C0,180 22,200 14,222"/>
                <path d="M382,20 C396,60 372,100 390,140 C400,180 378,200 386,222"/>
              </g>
              <!-- Primary flowing spines (4 edges, dense undulation) -->
              <g filter="url(#csGlow)" stroke-width="1.6">
                <path d="M22,20 C32,12 42,24 52,16 C62,8 72,22 82,14 C92,6 102,20 112,12 C122,4 132,18 142,10 C152,3 162,16 172,10 C182,4 192,16 200,12 C208,16 218,4 228,10 C238,16 248,3 258,10 C268,18 278,4 288,12 C298,20 308,6 318,14 C328,22 338,8 348,16 C358,24 368,12 378,20"/>
                <path d="M22,220 C32,228 42,216 52,224 C62,232 72,218 82,226 C92,234 102,220 112,228 C122,236 132,222 142,230 C152,237 162,224 172,230 C182,236 192,224 200,228 C208,224 218,236 228,230 C238,224 248,237 258,230 C268,222 278,236 288,228 C298,220 308,234 318,226 C328,218 338,232 348,224 C358,216 368,228 378,220"/>
                <path d="M20,22 C12,32 24,42 16,52 C8,62 22,72 14,82 C6,92 20,102 12,120 C4,138 20,148 12,168 C4,188 18,198 12,210 C8,216 14,220 18,222"/>
                <path d="M380,22 C388,32 376,42 384,52 C392,62 378,72 386,82 C394,92 380,102 388,120 C396,138 380,148 388,168 C396,188 382,198 388,210 C392,216 386,220 382,222"/>
              </g>
              <!-- Secondary inner spines (parallel echo) -->
              <g filter="url(#csGlow)" stroke-width="0.8" opacity="0.5">
                <path d="M35,30 C55,20 75,38 95,26 C115,14 135,32 155,22 C175,12 195,28 200,24 C205,28 225,12 245,22 C265,32 285,14 305,26 C325,38 345,20 365,30"/>
                <path d="M35,210 C55,220 75,202 95,214 C115,226 135,208 155,218 C175,228 195,212 200,216 C205,212 225,228 245,218 C265,208 285,226 305,214 C325,202 345,220 365,210"/>
                <path d="M30,35 C20,55 38,75 26,95 C14,115 32,135 22,155 C12,175 28,195 24,210"/>
                <path d="M370,35 C380,55 362,75 374,95 C386,115 368,135 378,155 C388,175 372,195 376,210"/>
              </g>
              <!-- Dense thorn field - top -->
              <g stroke-width="0.6">
                <path d="M37,19 L33,4 M39,20 L44,3"/><path d="M57,14 L54,1 M59,13 L63,0"/><path d="M77,18 L74,4 M79,19 L83,3"/>
                <path d="M97,12 L94,0 M99,11 L103,0"/><path d="M117,8 L114,0 M119,7 L123,0"/><path d="M137,14 L134,1 M139,15 L143,0"/>
                <path d="M157,8 L154,0 M159,7 L163,0"/><path d="M177,12 L174,0 M179,13 L183,0"/><path d="M197,11 L195,0 M199,10 L203,0"/>
                <path d="M223,8 L220,0 M225,7 L229,0"/><path d="M243,14 L240,1 M245,15 L249,0"/><path d="M263,12 L260,0 M265,11 L269,0"/>
                <path d="M283,8 L280,0 M285,7 L289,0"/><path d="M303,14 L300,1 M305,15 L309,0"/><path d="M323,18 L320,4 M325,19 L329,3"/>
                <path d="M343,12 L340,0 M345,11 L349,0"/><path d="M363,16 L360,3 M365,17 L369,2"/>
              </g>
              <!-- Dense thorn field - bottom -->
              <g stroke-width="0.6">
                <path d="M37,221 L33,236 M39,220 L44,237"/><path d="M57,226 L54,239 M59,227 L63,240"/>
                <path d="M97,228 L94,240 M99,229 L103,240"/><path d="M137,226 L134,239 M139,225 L143,240"/>
                <path d="M177,228 L174,240 M179,227 L183,240"/><path d="M217,224 L214,238 M219,223 L223,239"/>
                <path d="M257,228 L254,240 M259,229 L263,240"/><path d="M297,226 L294,239 M299,225 L303,240"/>
                <path d="M337,224 L334,238 M339,223 L343,239"/><path d="M367,222 L364,237 M369,221 L373,238"/>
              </g>
              <!-- Dense thorn field - left -->
              <g stroke-width="0.6">
                <path d="M19,42 L4,38 M20,44 L3,49"/><path d="M15,62 L1,58 M14,64 L0,69"/>
                <path d="M11,92 L0,88 M10,94 L0,99"/><path d="M17,112 L3,108 M16,114 L2,119"/>
                <path d="M11,142 L0,138 M10,144 L0,149"/><path d="M15,172 L1,168 M14,174 L0,179"/>
                <path d="M13,200 L0,196 M12,202 L0,207"/>
              </g>
              <!-- Dense thorn field - right -->
              <g stroke-width="0.6">
                <path d="M381,42 L396,38 M380,44 L397,49"/><path d="M385,62 L399,58 M386,64 L400,69"/>
                <path d="M389,92 L400,88 M390,94 L400,99"/><path d="M383,112 L397,108 M384,114 L398,119"/>
                <path d="M389,142 L400,138 M390,144 L400,149"/><path d="M385,172 L399,168 M386,174 L400,179"/>
                <path d="M387,200 L400,196 M388,202 L400,207"/>
              </g>
              <!-- Micro thorns (tertiary, very fine) -->
              <g stroke-width="0.3" opacity="0.4">
                <path d="M47,17 L46,10"/><path d="M67,16 L66,9"/><path d="M87,15 L86,8"/><path d="M107,10 L106,4"/><path d="M127,6 L126,1"/>
                <path d="M147,12 L146,6"/><path d="M167,9 L166,3"/><path d="M187,13 L186,7"/><path d="M213,9 L212,3"/><path d="M233,12 L232,6"/>
                <path d="M253,14 L252,8"/><path d="M273,10 L272,4"/><path d="M293,12 L292,6"/><path d="M313,16 L312,10"/><path d="M333,14 L332,8"/>
                <path d="M353,13 L352,7"/><path d="M373,17 L372,11"/>
              </g>
              <!-- Corner sigil nodes (large, elaborate) -->
              <g fill="currentColor" filter="url(#csGlow)">
                <!-- Top-left sigil -->
                <circle cx="20" cy="20" r="6" opacity="0.7"/><circle cx="20" cy="20" r="3" opacity="0.9"/>
                <path d="M20,20 L4,4 M20,20 L36,4 M20,20 L4,36 M20,20 L36,36" fill="none" stroke-width="0.8"/>
                <path d="M20,20 L8,14 M20,20 L14,8 M20,20 L26,8 M20,20 L32,14 M20,20 L32,26 M20,20 L26,32 M20,20 L14,32 M20,20 L8,26" fill="none" stroke-width="0.5" opacity="0.6"/>
                <path d="M12,12 C16,8 24,8 28,12 C32,16 32,24 28,28 C24,32 16,32 12,28 C8,24 8,16 12,12Z" fill="none" stroke-width="0.4" opacity="0.4"/>
                <!-- Top-right sigil -->
                <circle cx="380" cy="20" r="6" opacity="0.7"/><circle cx="380" cy="20" r="3" opacity="0.9"/>
                <path d="M380,20 L396,4 M380,20 L364,4 M380,20 L396,36 M380,20 L364,36" fill="none" stroke-width="0.8"/>
                <path d="M380,20 L392,14 M380,20 L386,8 M380,20 L374,8 M380,20 L368,14 M380,20 L368,26 M380,20 L374,32 M380,20 L386,32 M380,20 L392,26" fill="none" stroke-width="0.5" opacity="0.6"/>
                <path d="M372,12 C376,8 384,8 388,12 C392,16 392,24 388,28 C384,32 376,32 372,28 C368,24 368,16 372,12Z" fill="none" stroke-width="0.4" opacity="0.4"/>
                <!-- Bottom-left sigil -->
                <circle cx="20" cy="220" r="6" opacity="0.7"/><circle cx="20" cy="220" r="3" opacity="0.9"/>
                <path d="M20,220 L4,204 M20,220 L36,204 M20,220 L4,236 M20,220 L36,236" fill="none" stroke-width="0.8"/>
                <path d="M20,220 L8,214 M20,220 L14,208 M20,220 L26,208 M20,220 L32,214 M20,220 L32,226 M20,220 L26,232 M20,220 L14,232 M20,220 L8,226" fill="none" stroke-width="0.5" opacity="0.6"/>
                <path d="M12,212 C16,208 24,208 28,212 C32,216 32,224 28,228 C24,232 16,232 12,228 C8,224 8,216 12,212Z" fill="none" stroke-width="0.4" opacity="0.4"/>
                <!-- Bottom-right sigil -->
                <circle cx="380" cy="220" r="6" opacity="0.7"/><circle cx="380" cy="220" r="3" opacity="0.9"/>
                <path d="M380,220 L396,204 M380,220 L364,204 M380,220 L396,236 M380,220 L364,236" fill="none" stroke-width="0.8"/>
                <path d="M380,220 L392,214 M380,220 L386,208 M380,220 L374,208 M380,220 L368,214 M380,220 L368,226 M380,220 L374,232 M380,220 L386,232 M380,220 L392,226" fill="none" stroke-width="0.5" opacity="0.6"/>
                <path d="M372,212 C376,208 384,208 388,212 C392,216 392,224 388,228 C384,232 376,232 372,228 C368,224 368,216 372,212Z" fill="none" stroke-width="0.4" opacity="0.4"/>
              </g>
              <!-- Flowing interior veins connecting edges -->
              <g stroke-width="0.4" opacity="0.25">
                <path d="M30,30 C80,50 120,30 160,45 C200,60 240,35 280,50 C320,65 360,40 370,30"/>
                <path d="M30,210 C80,190 120,210 160,195 C200,180 240,205 280,190 C320,175 360,200 370,210"/>
                <path d="M30,30 C50,80 30,120 45,160 C55,190 40,200 30,210"/>
                <path d="M370,30 C350,80 370,120 355,160 C345,190 360,200 370,210"/>
              </g>
              <!-- Central void sigil -->
              <g opacity="0.15" filter="url(#csGlow)">
                <circle cx="200" cy="120" r="10" stroke-width="0.6" fill="none"/>
                <circle cx="200" cy="120" r="6" stroke-width="0.4" fill="none"/>
                <circle cx="200" cy="120" r="2.5" fill="currentColor"/>
                <path d="M200,110 L200,102 M200,130 L200,138 M190,120 L182,120 M210,120 L218,120" stroke-width="0.5" fill="none"/>
                <path d="M193,113 L188,108 M207,113 L212,108 M207,127 L212,132 M193,127 L188,132" stroke-width="0.4" fill="none"/>
              </g>
            </g>
          </svg>
        </div>

        <!-- FANTASY: forged iron scrollwork, enchanted borders, shield crest, celtic knots -->
        <div class="stage-frame fantasy" aria-hidden="true">
          <svg viewBox="0 0 400 240" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
            <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
              <!-- Outer frame band (forged iron edge) -->
              <rect x="6" y="6" width="388" height="228" rx="6" stroke-width="1.8" opacity="0.6"/>
              <rect x="10" y="10" width="380" height="220" rx="5" stroke-width="0.5" opacity="0.3"/>
              <!-- Top edge vine scrollwork (dense, with spiral tendrils) -->
              <path d="M32,12 C38,6 44,8 50,12 C54,15 56,12 60,8 C64,4 70,3 76,6 C82,9 84,14 80,18 C76,22 72,18 68,14 C64,10 68,6 74,4" stroke-width="1.0"/>
              <path d="M76,6 C82,4 88,8 94,12 C100,16 104,12 108,8 C112,4 118,2 124,5 C130,8 132,14 128,18 C124,22 120,18 116,14 C112,10 116,5 122,3" stroke-width="1.0"/>
              <path d="M124,5 C130,3 136,6 142,10 C148,14 152,10 156,6 C160,2 166,1 172,4 C178,7 180,12 176,16 C172,20 168,16 164,12 C160,8 164,4 170,2" stroke-width="1.0"/>
              <path d="M172,4 C178,2 186,6 194,10 C200,13 206,10 212,6" stroke-width="1.0"/>
              <path d="M212,6 C218,2 224,1 230,4 C236,7 238,12 234,16 C230,20 226,16 222,12 C218,8 222,4 228,2" stroke-width="1.0"/>
              <path d="M230,4 C236,2 242,5 248,8 C254,12 258,8 262,4 C268,1 274,2 280,6 C286,10 284,16 280,18 C276,20 272,16 270,12" stroke-width="1.0"/>
              <path d="M280,6 C286,4 292,6 298,10 C304,14 308,10 312,6 C318,2 324,2 330,5 C336,8 334,14 330,16 C326,18 324,14 322,10" stroke-width="1.0"/>
              <path d="M330,5 C336,3 342,6 348,10 C354,14 360,10 366,8 C370,6 374,8 370,12" stroke-width="1.0"/>
              <!-- Top leaf fills (ornate, veined) -->
              <g fill="currentColor" opacity="0.2" stroke-width="0.5">
                <path d="M60,8 C56,2 48,0 44,4 C42,7 44,11 48,12 C52,13 56,11 60,8Z"/>
                <path d="M108,8 C104,2 96,0 92,4 C90,7 92,11 96,12 C100,13 104,11 108,8Z"/>
                <path d="M156,6 C152,0 144,0 140,3 C138,6 140,10 144,11 C148,12 152,10 156,6Z"/>
                <path d="M262,4 C258,0 250,0 246,3 C244,6 246,10 250,11 C254,12 258,10 262,4Z"/>
                <path d="M312,6 C308,0 300,0 296,3 C294,6 296,10 300,11 C304,12 308,10 312,6Z"/>
              </g>
              <!-- Bottom edge vine scrollwork (mirrored) -->
              <path d="M32,228 C38,234 44,232 50,228 C54,225 56,228 60,232 C64,236 70,237 76,234 C82,231 84,226 80,222 C76,218 72,222 68,226" stroke-width="1.0"/>
              <path d="M76,234 C82,236 88,232 94,228 C100,224 104,228 108,232 C112,236 118,238 124,235 C130,232 132,226 128,222" stroke-width="1.0"/>
              <path d="M124,235 C130,237 136,234 142,230 C148,226 152,230 156,234 C160,238 166,239 172,236 C178,233 180,228 176,224" stroke-width="1.0"/>
              <path d="M172,236 C178,238 186,234 194,230 C200,227 206,230 212,234" stroke-width="1.0"/>
              <path d="M212,234 C218,238 224,239 230,236 C236,233 238,228 234,224" stroke-width="1.0"/>
              <path d="M230,236 C236,238 242,235 248,232 C254,228 258,232 262,236 C268,239 274,238 280,234 C286,230 284,224 280,222" stroke-width="1.0"/>
              <path d="M280,234 C286,236 292,234 298,230 C304,226 308,230 312,234 C318,238 324,238 330,235" stroke-width="1.0"/>
              <path d="M330,235 C336,237 342,234 348,230 C354,226 360,230 366,232 C370,234 374,232 370,228" stroke-width="1.0"/>
              <g fill="currentColor" opacity="0.2" stroke-width="0.5">
                <path d="M60,232 C56,238 48,240 44,236 C42,233 44,229 48,228 C52,227 56,229 60,232Z"/>
                <path d="M108,232 C104,238 96,240 92,236 C90,233 92,229 96,228Z"/>
                <path d="M156,234 C152,240 144,240 140,237 C138,234 140,230 144,229Z"/>
                <path d="M312,234 C308,240 300,240 296,237 C294,234 296,230 300,229Z"/>
              </g>
              <!-- Left edge vine scrollwork -->
              <path d="M12,32 C6,38 8,44 12,50 C15,54 12,58 8,62 C4,66 3,72 6,78 C9,84 14,84 18,80 C22,76 18,72 14,68" stroke-width="1.0"/>
              <path d="M6,78 C4,84 6,90 10,96 C14,102 10,108 6,114 C2,120 3,126 6,132 C9,138 14,138 18,134 C22,130 18,126 14,122" stroke-width="1.0"/>
              <path d="M6,132 C4,138 6,144 10,150 C14,156 10,162 6,168 C2,174 3,180 6,186 C9,192 14,192 18,188 C22,184 18,180 14,176" stroke-width="1.0"/>
              <path d="M6,186 C4,192 8,198 12,204 C15,208 12,212 8,216 C6,218 8,222 12,220" stroke-width="1.0"/>
              <g fill="currentColor" opacity="0.2" stroke-width="0.5">
                <path d="M8,62 C2,58 0,50 4,46 C7,44 11,46 12,50Z"/>
                <path d="M6,114 C0,110 0,102 3,98 C6,96 10,98 10,102Z"/>
                <path d="M6,168 C0,164 0,156 3,152 C6,150 10,152 10,156Z"/>
              </g>
              <!-- Right edge vine scrollwork -->
              <path d="M388,32 C394,38 392,44 388,50 C385,54 388,58 392,62 C396,66 397,72 394,78 C391,84 386,84 382,80" stroke-width="1.0"/>
              <path d="M394,78 C396,84 394,90 390,96 C386,102 390,108 394,114 C398,120 397,126 394,132 C391,138 386,138 382,134" stroke-width="1.0"/>
              <path d="M394,132 C396,138 394,144 390,150 C386,156 390,162 394,168 C398,174 397,180 394,186 C391,192 386,192 382,188" stroke-width="1.0"/>
              <path d="M394,186 C396,192 392,198 388,204 C385,208 388,212 392,216 C394,218 392,222 388,220" stroke-width="1.0"/>
              <g fill="currentColor" opacity="0.2" stroke-width="0.5">
                <path d="M392,62 C398,58 400,50 396,46 C393,44 389,46 388,50Z"/>
                <path d="M394,114 C400,110 400,102 397,98 C394,96 390,98 390,102Z"/>
                <path d="M394,168 C400,164 400,156 397,152 C394,150 390,152 390,156Z"/>
              </g>
              <!-- Celtic knot corners (elaborate interlace) -->
              <g stroke-width="1.2">
                <path d="M24,24 C18,18 12,18 10,22 C8,26 12,30 16,30 C20,30 24,26 24,22 C24,18 20,14 16,14 C12,14 8,18 8,22 C8,28 14,34 22,34 C28,34 34,28 34,22 C34,14 28,8 22,8"/>
                <path d="M376,24 C382,18 388,18 390,22 C392,26 388,30 384,30 C380,30 376,26 376,22 C376,18 380,14 384,14 C388,14 392,18 392,22 C392,28 386,34 378,34 C372,34 366,28 366,22 C366,14 372,8 378,8"/>
                <path d="M24,216 C18,222 12,222 10,218 C8,214 12,210 16,210 C20,210 24,214 24,218 C24,222 20,226 16,226 C12,226 8,222 8,218 C8,212 14,206 22,206 C28,206 34,212 34,218 C34,226 28,232 22,232"/>
                <path d="M376,216 C382,222 388,222 390,218 C392,214 388,210 384,210 C380,210 376,214 376,218 C376,222 380,226 384,226 C388,226 392,222 392,218 C392,212 386,206 378,206 C372,206 366,212 366,218 C366,226 372,232 378,232"/>
              </g>
              <!-- Shield crest at top center -->
              <g stroke-width="0.9">
                <path d="M184,2 L216,2 L220,8 L218,22 C214,32 208,38 200,42 C192,38 186,32 182,22 L180,8 Z" fill="currentColor" opacity="0.12"/>
                <path d="M184,2 L216,2 L220,8 L218,22 C214,32 208,38 200,42 C192,38 186,32 182,22 L180,8 Z"/>
                <path d="M200,6 L200,36" stroke-width="0.5"/><path d="M190,14 L210,14" stroke-width="0.5"/><path d="M188,22 L212,22" stroke-width="0.4"/>
                <path d="M194,8 C196,12 200,16 200,20" stroke-width="0.35"/><path d="M206,8 C204,12 200,16 200,20" stroke-width="0.35"/>
                <circle cx="200" cy="28" r="2.5" stroke-width="0.4" fill="currentColor" opacity="0.2"/>
              </g>
              <!-- Decorative chain links along inner border -->
              <g stroke-width="0.4" opacity="0.2">
                <rect x="26" y="26" width="348" height="188" rx="4"/>
                <ellipse cx="55" cy="26" rx="4" ry="2.5"/><ellipse cx="75" cy="26" rx="4" ry="2.5"/><ellipse cx="95" cy="26" rx="4" ry="2.5"/>
                <ellipse cx="115" cy="26" rx="4" ry="2.5"/><ellipse cx="135" cy="26" rx="4" ry="2.5"/><ellipse cx="155" cy="26" rx="4" ry="2.5"/>
                <ellipse cx="245" cy="26" rx="4" ry="2.5"/><ellipse cx="265" cy="26" rx="4" ry="2.5"/><ellipse cx="285" cy="26" rx="4" ry="2.5"/>
                <ellipse cx="305" cy="26" rx="4" ry="2.5"/><ellipse cx="325" cy="26" rx="4" ry="2.5"/><ellipse cx="345" cy="26" rx="4" ry="2.5"/>
                <ellipse cx="55" cy="214" rx="4" ry="2.5"/><ellipse cx="75" cy="214" rx="4" ry="2.5"/><ellipse cx="95" cy="214" rx="4" ry="2.5"/>
                <ellipse cx="115" cy="214" rx="4" ry="2.5"/><ellipse cx="135" cy="214" rx="4" ry="2.5"/><ellipse cx="155" cy="214" rx="4" ry="2.5"/>
                <ellipse cx="245" cy="214" rx="4" ry="2.5"/><ellipse cx="265" cy="214" rx="4" ry="2.5"/><ellipse cx="285" cy="214" rx="4" ry="2.5"/>
                <ellipse cx="305" cy="214" rx="4" ry="2.5"/><ellipse cx="325" cy="214" rx="4" ry="2.5"/><ellipse cx="345" cy="214" rx="4" ry="2.5"/>
              </g>
              <!-- Sword silhouettes flanking shield -->
              <g stroke-width="0.6" opacity="0.35">
                <path d="M170,6 L170,28 M168,8 L172,8 M166,28 L174,28 M168,30 L172,30"/>
                <path d="M230,6 L230,28 M228,8 L232,8 M226,28 L234,28 M228,30 L232,30"/>
              </g>
            </g>
          </svg>
        </div>

        <!-- ANIME: manga panel, action bursts, speed lines, halftone, impact stars -->
        <div class="stage-frame anime" aria-hidden="true">
          <svg viewBox="0 0 400 240" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
            <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
              <!-- Bold outer frame (brush-weight variation) -->
              <path d="M14,10 L386,10" stroke-width="5.5"/>
              <path d="M14,230 L386,230" stroke-width="6"/>
              <path d="M10,14 L10,226" stroke-width="6"/>
              <path d="M390,14 L390,226" stroke-width="5"/>
              <!-- Inner panel line -->
              <rect x="22" y="20" width="356" height="200" rx="2" stroke-width="1.5"/>
              <!-- Corner action bursts - Top Left (explosive, many triangles) -->
              <g fill="currentColor" stroke="none">
                <polygon points="10,10 0,0 22,5" opacity="0.95"/>
                <polygon points="10,10 5,0 15,3" opacity="0.9"/>
                <polygon points="10,10 0,5 5,15" opacity="0.9"/>
                <polygon points="10,10 2,2 12,7" opacity="0.85"/>
                <polygon points="10,10 0,12 8,16" opacity="0.8"/>
                <polygon points="10,10 12,0 16,8" opacity="0.8"/>
                <polygon points="10,10 0,0 8,3 0,8" opacity="0.7"/>
              </g>
              <!-- Corner burst - Top Right -->
              <g fill="currentColor" stroke="none">
                <polygon points="390,10 400,0 378,5" opacity="0.95"/>
                <polygon points="390,10 395,0 385,3" opacity="0.9"/>
                <polygon points="390,10 400,5 395,15" opacity="0.9"/>
                <polygon points="390,10 398,2 388,7" opacity="0.85"/>
                <polygon points="390,10 400,12 392,16" opacity="0.8"/>
                <polygon points="390,10 388,0 384,8" opacity="0.8"/>
              </g>
              <!-- Corner burst - Bottom Left -->
              <g fill="currentColor" stroke="none">
                <polygon points="10,230 0,240 22,235" opacity="0.95"/>
                <polygon points="10,230 5,240 15,237" opacity="0.9"/>
                <polygon points="10,230 0,235 5,225" opacity="0.9"/>
                <polygon points="10,230 2,238 12,233" opacity="0.85"/>
                <polygon points="10,230 0,228 8,224" opacity="0.8"/>
                <polygon points="10,230 12,240 16,232" opacity="0.8"/>
              </g>
              <!-- Corner burst - Bottom Right -->
              <g fill="currentColor" stroke="none">
                <polygon points="390,230 400,240 378,235" opacity="0.95"/>
                <polygon points="390,230 395,240 385,237" opacity="0.9"/>
                <polygon points="390,230 400,235 395,225" opacity="0.9"/>
                <polygon points="390,230 398,238 388,233" opacity="0.85"/>
                <polygon points="390,230 400,228 392,224" opacity="0.8"/>
                <polygon points="390,230 388,240 384,232" opacity="0.8"/>
              </g>
              <!-- Speed lines from ALL corners (dense, varied weight) -->
              <g opacity="0.6">
                <path d="M0,0 L55,38" stroke-width="0.7"/><path d="M4,0 L52,30" stroke-width="0.5"/>
                <path d="M0,4 L38,34" stroke-width="0.5"/><path d="M8,0 L48,24" stroke-width="0.4"/>
                <path d="M0,8 L30,28" stroke-width="0.4"/><path d="M12,0 L44,18" stroke-width="0.3"/>
                <path d="M0,14 L24,26" stroke-width="0.3"/><path d="M16,0 L40,14" stroke-width="0.25"/>
              </g>
              <g opacity="0.6">
                <path d="M400,0 L345,38" stroke-width="0.7"/><path d="M396,0 L348,30" stroke-width="0.5"/>
                <path d="M400,4 L362,34" stroke-width="0.5"/><path d="M392,0 L352,24" stroke-width="0.4"/>
                <path d="M400,8 L370,28" stroke-width="0.4"/><path d="M388,0 L356,18" stroke-width="0.3"/>
                <path d="M400,14 L376,26" stroke-width="0.3"/><path d="M384,0 L360,14" stroke-width="0.25"/>
              </g>
              <g opacity="0.6">
                <path d="M0,240 L55,202" stroke-width="0.7"/><path d="M4,240 L52,210" stroke-width="0.5"/>
                <path d="M0,236 L38,206" stroke-width="0.5"/><path d="M8,240 L48,216" stroke-width="0.4"/>
                <path d="M0,232 L30,212" stroke-width="0.4"/><path d="M12,240 L44,222" stroke-width="0.3"/>
              </g>
              <g opacity="0.6">
                <path d="M400,240 L345,202" stroke-width="0.7"/><path d="M396,240 L348,210" stroke-width="0.5"/>
                <path d="M400,236 L362,206" stroke-width="0.5"/><path d="M392,240 L352,216" stroke-width="0.4"/>
                <path d="M400,232 L370,212" stroke-width="0.4"/><path d="M388,240 L356,222" stroke-width="0.3"/>
              </g>
              <!-- Large impact stars (multi-point, complex) -->
              <g fill="currentColor" stroke="none">
                <!-- Top center star -->
                <polygon points="200,3 202,0 204,3 206,1 205,5 210,4 206,7 209,10 205,9 204,13 202,9 200,13 199,9 195,10 198,7 194,4 199,5 198,1" opacity="0.8"/>
                <!-- Bottom center star -->
                <polygon points="200,237 202,240 204,237 206,239 205,235 210,236 206,233 209,230 205,231 204,227 202,231 200,227 199,231 195,230 198,233 194,236 199,235 198,239" opacity="0.8"/>
                <!-- Left center star -->
                <polygon points="3,120 0,118 3,116 1,114 5,115 4,110 7,114 10,111 9,115 13,116 9,118 13,120 9,121 10,125 7,122 4,126 5,121 1,122" opacity="0.7"/>
                <!-- Right center star -->
                <polygon points="397,120 400,118 397,116 399,114 395,115 396,110 393,114 390,111 391,115 387,116 391,118 387,120 391,121 390,125 393,122 396,126 395,121 399,122" opacity="0.7"/>
              </g>
              <!-- Small sparkle stars scattered in border -->
              <g fill="currentColor" stroke="none" opacity="0.65">
                <polygon points="50,6 52,2 54,6 52,10"/><polygon points="49,6 52,4 55,6 52,8"/>
                <polygon points="100,8 102,4 104,8 102,12"/><polygon points="99,8 102,6 105,8 102,10"/>
                <polygon points="300,8 302,4 304,8 302,12"/><polygon points="299,8 302,6 305,8 302,10"/>
                <polygon points="350,6 352,2 354,6 352,10"/><polygon points="349,6 352,4 355,6 352,8"/>
                <polygon points="50,234 52,230 54,234 52,238"/><polygon points="49,234 52,232 55,234 52,236"/>
                <polygon points="150,234 152,230 154,234 152,238"/><polygon points="149,234 152,232 155,234 152,236"/>
                <polygon points="250,234 252,230 254,234 252,238"/><polygon points="249,234 252,232 255,234 252,236"/>
                <polygon points="350,234 352,230 354,234 352,238"/><polygon points="349,234 352,232 355,234 352,236"/>
              </g>
              <!-- Diagonal energy slashes (paired, across border zones) -->
              <g stroke-width="1.0" opacity="0.25">
                <path d="M70,10 L76,20"/><path d="M74,10 L80,20"/>
                <path d="M130,10 L136,20"/><path d="M134,10 L140,20"/>
                <path d="M260,10 L266,20"/><path d="M264,10 L270,20"/>
                <path d="M320,10 L326,20"/><path d="M324,10 L330,20"/>
                <path d="M70,230 L76,220"/><path d="M74,230 L80,220"/>
                <path d="M130,230 L136,220"/><path d="M134,230 L140,220"/>
                <path d="M260,230 L266,220"/><path d="M264,230 L270,220"/>
                <path d="M320,230 L326,220"/><path d="M324,230 L330,220"/>
              </g>
              <!-- Halftone dot clusters in corners (manga screen tone) -->
              <g fill="currentColor" stroke="none" opacity="0.15">
                <circle cx="18" cy="18" r="1.5"/><circle cx="24" cy="18" r="1.2"/><circle cx="18" cy="24" r="1.2"/><circle cx="24" cy="24" r="0.9"/>
                <circle cx="30" cy="18" r="0.9"/><circle cx="18" cy="30" r="0.9"/><circle cx="30" cy="24" r="0.7"/><circle cx="24" cy="30" r="0.7"/>
                <circle cx="382" cy="18" r="1.5"/><circle cx="376" cy="18" r="1.2"/><circle cx="382" cy="24" r="1.2"/><circle cx="376" cy="24" r="0.9"/>
                <circle cx="370" cy="18" r="0.9"/><circle cx="382" cy="30" r="0.9"/><circle cx="370" cy="24" r="0.7"/><circle cx="376" cy="30" r="0.7"/>
                <circle cx="18" cy="222" r="1.5"/><circle cx="24" cy="222" r="1.2"/><circle cx="18" cy="216" r="1.2"/><circle cx="24" cy="216" r="0.9"/>
                <circle cx="30" cy="222" r="0.9"/><circle cx="18" cy="210" r="0.9"/><circle cx="30" cy="216" r="0.7"/><circle cx="24" cy="210" r="0.7"/>
                <circle cx="382" cy="222" r="1.5"/><circle cx="376" cy="222" r="1.2"/><circle cx="382" cy="216" r="1.2"/><circle cx="376" cy="216" r="0.9"/>
                <circle cx="370" cy="222" r="0.9"/><circle cx="382" cy="210" r="0.9"/><circle cx="370" cy="216" r="0.7"/><circle cx="376" cy="210" r="0.7"/>
              </g>
            </g>
          </svg>
        </div>

        <!-- FUTURISTIC: HUD brackets, targeting reticles, data blocks, tech arcs -->
        <div class="stage-frame futuristic" aria-hidden="true">
          <svg viewBox="0 0 400 240" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
            <defs><filter id="hudGlow"><feGaussianBlur stdDeviation="1" result="b"/><feMerge><feMergeNode in="b"/><feMergeNode in="SourceGraphic"/></feMerge></filter></defs>
            <g fill="none" stroke="currentColor" stroke-linecap="square" filter="url(#hudGlow)">
              <!-- L-bracket corners with tick marks -->
              <!-- Top-left bracket -->
              <path d="M8,30 L8,8 L30,8" stroke-width="1.5"/>
              <path d="M8,35 L8,40" stroke-width="0.6"/><path d="M8,44 L8,48" stroke-width="0.4"/><path d="M8,51 L8,54" stroke-width="0.3"/>
              <path d="M35,8 L40,8" stroke-width="0.6"/><path d="M44,8 L48,8" stroke-width="0.4"/><path d="M51,8 L54,8" stroke-width="0.3"/>
              <!-- Top-right bracket -->
              <path d="M392,30 L392,8 L370,8" stroke-width="1.5"/>
              <path d="M392,35 L392,40" stroke-width="0.6"/><path d="M392,44 L392,48" stroke-width="0.4"/><path d="M392,51 L392,54" stroke-width="0.3"/>
              <path d="M365,8 L360,8" stroke-width="0.6"/><path d="M356,8 L352,8" stroke-width="0.4"/><path d="M349,8 L346,8" stroke-width="0.3"/>
              <!-- Bottom-left bracket -->
              <path d="M8,210 L8,232 L30,232" stroke-width="1.5"/>
              <path d="M8,205 L8,200" stroke-width="0.6"/><path d="M8,196 L8,192" stroke-width="0.4"/><path d="M8,189 L8,186" stroke-width="0.3"/>
              <path d="M35,232 L40,232" stroke-width="0.6"/><path d="M44,232 L48,232" stroke-width="0.4"/><path d="M51,232 L54,232" stroke-width="0.3"/>
              <!-- Bottom-right bracket -->
              <path d="M392,210 L392,232 L370,232" stroke-width="1.5"/>
              <path d="M392,205 L392,200" stroke-width="0.6"/><path d="M392,196 L392,192" stroke-width="0.4"/><path d="M392,189 L392,186" stroke-width="0.3"/>
              <path d="M365,232 L360,232" stroke-width="0.6"/><path d="M356,232 L352,232" stroke-width="0.4"/><path d="M349,232 L346,232" stroke-width="0.3"/>
              <!-- Edge midpoint targeting crosshairs -->
              <!-- Top center -->
              <path d="M195,6 L195,2 M205,6 L205,2 M200,8 L200,0" stroke-width="0.6"/>
              <path d="M192,6 L208,6" stroke-width="0.5"/>
              <!-- Bottom center -->
              <path d="M195,234 L195,238 M205,234 L205,238 M200,232 L200,240" stroke-width="0.6"/>
              <path d="M192,234 L208,234" stroke-width="0.5"/>
              <!-- Left center -->
              <path d="M6,115 L2,115 M6,125 L2,125 M8,120 L0,120" stroke-width="0.6"/>
              <path d="M6,112 L6,128" stroke-width="0.5"/>
              <!-- Right center -->
              <path d="M394,115 L398,115 M394,125 L398,125 M392,120 L400,120" stroke-width="0.6"/>
              <path d="M394,112 L394,128" stroke-width="0.5"/>
              <!-- Corner concentric arcs -->
              <path d="M22,8 A14,14 0 0,0 8,22" stroke-width="0.4" opacity="0.5"/>
              <path d="M26,8 A18,18 0 0,0 8,26" stroke-width="0.3" opacity="0.35"/>
              <path d="M378,8 A14,14 0 0,1 392,22" stroke-width="0.4" opacity="0.5"/>
              <path d="M374,8 A18,18 0 0,1 392,26" stroke-width="0.3" opacity="0.35"/>
              <path d="M8,218 A14,14 0 0,0 22,232" stroke-width="0.4" opacity="0.5"/>
              <path d="M8,214 A18,18 0 0,0 26,232" stroke-width="0.3" opacity="0.35"/>
              <path d="M392,218 A14,14 0 0,1 378,232" stroke-width="0.4" opacity="0.5"/>
              <path d="M392,214 A18,18 0 0,1 374,232" stroke-width="0.3" opacity="0.35"/>
              <!-- Data block readouts -->
              <g stroke-width="0.5" opacity="0.5">
                <rect x="60" y="3" width="18" height="6" rx="1"/><path d="M63,5 L66,5 M68,5 L72,5 M74,5 L75,5"/>
                <rect x="322" y="3" width="18" height="6" rx="1"/><path d="M325,5 L328,5 M330,5 L334,5 M336,5 L337,5"/>
                <rect x="60" y="231" width="18" height="6" rx="1"/><path d="M63,234 L66,234 M68,234 L72,234 M74,234 L75,234"/>
                <rect x="322" y="231" width="18" height="6" rx="1"/><path d="M325,234 L328,234 M330,234 L334,234 M336,234 L337,234"/>
              </g>
              <!-- Side data blocks -->
              <g stroke-width="0.5" opacity="0.4">
                <rect x="2" y="60" width="6" height="14" rx="1"/><path d="M4,63 L6,63 M4,66 L6,66 M4,69 L6,69"/>
                <rect x="2" y="166" width="6" height="14" rx="1"/><path d="M4,169 L6,169 M4,172 L6,172 M4,175 L6,175"/>
                <rect x="392" y="60" width="6" height="14" rx="1"/><path d="M394,63 L396,63 M394,66 L396,66 M394,69 L396,69"/>
                <rect x="392" y="166" width="6" height="14" rx="1"/><path d="M394,169 L396,169 M394,172 L396,172 M394,175 L396,175"/>
              </g>
              <!-- Diagonal hash marks in corners -->
              <g stroke-width="0.3" opacity="0.3">
                <path d="M14,14 L20,20"/><path d="M18,14 L24,20"/><path d="M22,14 L28,20"/>
                <path d="M386,14 L380,20"/><path d="M382,14 L376,20"/><path d="M378,14 L372,20"/>
                <path d="M14,226 L20,220"/><path d="M18,226 L24,220"/><path d="M22,226 L28,220"/>
                <path d="M386,226 L380,220"/><path d="M382,226 L376,220"/><path d="M378,226 L372,220"/>
              </g>
              <!-- Thin inner frame line -->
              <rect x="18" y="18" width="364" height="204" rx="2" stroke-width="0.25" opacity="0.2"/>
              <!-- Status indicator dots -->
              <g fill="currentColor" stroke="none" opacity="0.5">
                <circle cx="90" cy="6" r="1.2"/><circle cx="96" cy="6" r="1.2"/><circle cx="102" cy="6" r="0.8"/>
                <circle cx="298" cy="6" r="0.8"/><circle cx="304" cy="6" r="1.2"/><circle cx="310" cy="6" r="1.2"/>
                <circle cx="90" cy="234" r="1.2"/><circle cx="96" cy="234" r="1.2"/><circle cx="102" cy="234" r="0.8"/>
                <circle cx="298" cy="234" r="0.8"/><circle cx="304" cy="234" r="1.2"/><circle cx="310" cy="234" r="1.2"/>
              </g>
              <!-- Horizontal scan line hints -->
              <path d="M30,8 L56,8" stroke-width="0.15" opacity="0.15"/>
              <path d="M344,8 L370,8" stroke-width="0.15" opacity="0.15"/>
              <path d="M30,232 L56,232" stroke-width="0.15" opacity="0.15"/>
              <path d="M344,232 L370,232" stroke-width="0.15" opacity="0.15"/>
            </g>
          </svg>
        </div>

        <!-- RENAISSANCE: gilt museum frame, baroque scrollwork, volutes, acanthus, cartouche -->
        <div class="stage-frame renaissance" aria-hidden="true">
          <svg viewBox="0 0 400 240" preserveAspectRatio="none" xmlns="http://www.w3.org/2000/svg">
            <g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
              <!-- Outer gilt molding (double line with fill) -->
              <rect x="4" y="4" width="392" height="232" rx="6" stroke-width="2.0" opacity="0.7"/>
              <rect x="8" y="8" width="384" height="224" rx="5" stroke-width="0.8" opacity="0.5"/>
              <rect x="6" y="6" width="388" height="228" rx="5.5" stroke-width="0.3" fill="currentColor" opacity="0.04"/>
              <!-- Inner molding line -->
              <rect x="28" y="24" width="344" height="192" rx="3" stroke-width="0.6" opacity="0.35"/>
              <rect x="30" y="26" width="340" height="188" rx="2.5" stroke-width="0.25" opacity="0.2"/>
              <!-- Top edge acanthus scrollwork (dense, layered) -->
              <path d="M35,14 C40,8 46,10 52,14 C56,17 58,13 62,9 C66,5 72,4 78,7 C84,10 86,16 82,19 C78,22 74,18 70,14 C66,10 70,6 76,4" stroke-width="1.1"/>
              <path d="M78,7 C84,5 90,8 96,12 C102,16 106,12 110,8 C114,4 120,3 126,6 C132,9 134,15 130,18 C126,21 122,17 118,13" stroke-width="1.1"/>
              <path d="M126,6 C132,4 138,7 144,11 C150,15 154,11 158,7 C162,3 168,2 174,5 C180,8 182,14 178,17 C174,20 170,16 166,12" stroke-width="1.1"/>
              <path d="M174,5 C180,3 188,7 196,11 C200,13 204,11 208,7" stroke-width="1.1"/>
              <path d="M208,7 C212,3 218,2 224,5 C230,8 232,14 228,17 C224,20 220,16 216,12" stroke-width="1.1"/>
              <path d="M224,5 C230,3 236,6 242,10 C248,14 252,10 256,6 C262,2 268,3 274,7 C280,11 278,17 274,19 C270,21 268,17 266,13" stroke-width="1.1"/>
              <path d="M274,7 C280,5 286,7 292,11 C298,15 302,11 306,7 C312,3 318,3 324,6 C330,9 328,15 324,17" stroke-width="1.1"/>
              <path d="M324,6 C330,4 336,7 342,11 C348,15 354,11 360,9 C364,7 368,10 366,14" stroke-width="1.1"/>
              <!-- Top acanthus leaf fills (many, ornate) -->
              <g fill="currentColor" opacity="0.15" stroke-width="0.5">
                <path d="M62,9 C58,3 50,1 46,5 C44,8 46,12 50,13 C54,14 58,12 62,9Z"/>
                <path d="M110,8 C106,2 98,0 94,4 C92,7 94,11 98,12Z"/>
                <path d="M158,7 C154,1 146,0 142,3 C140,6 142,10 146,11Z"/>
                <path d="M256,6 C252,0 244,0 240,3 C238,6 240,10 244,11Z"/>
                <path d="M306,7 C302,1 294,0 290,3 C288,6 290,10 294,11Z"/>
                <path d="M82,19 C86,22 90,20 88,16 C86,13 82,14 80,17Z"/>
                <path d="M130,18 C134,21 138,19 136,15 C134,12 130,13 128,16Z"/>
                <path d="M178,17 C182,20 186,18 184,14 C182,11 178,12 176,15Z"/>
                <path d="M228,17 C232,20 236,18 234,14 C232,11 228,12 226,15Z"/>
                <path d="M274,19 C278,22 282,20 280,16 C278,13 274,14 272,17Z"/>
                <path d="M324,17 C328,20 332,18 330,14 C328,11 324,12 322,15Z"/>
              </g>
              <!-- Bottom edge scrollwork -->
              <path d="M35,226 C40,232 46,230 52,226 C56,223 58,227 62,231 C66,235 72,236 78,233 C84,230 86,224 82,221" stroke-width="1.1"/>
              <path d="M78,233 C84,235 90,232 96,228 C102,224 106,228 110,232 C114,236 120,237 126,234 C132,231 134,225 130,222" stroke-width="1.1"/>
              <path d="M126,234 C132,236 138,233 144,229 C150,225 154,229 158,233 C162,237 168,238 174,235 C180,232 182,226 178,223" stroke-width="1.1"/>
              <path d="M174,235 C180,237 188,233 196,229 C200,227 204,229 208,233" stroke-width="1.1"/>
              <path d="M208,233 C212,237 218,238 224,235 C230,232 232,226 228,223" stroke-width="1.1"/>
              <path d="M224,235 C230,237 236,234 242,230 C248,226 252,230 256,234 C262,238 268,237 274,233 C280,229 278,223 274,221" stroke-width="1.1"/>
              <path d="M274,233 C280,235 286,233 292,229 C298,225 302,229 306,233 C312,237 318,237 324,234" stroke-width="1.1"/>
              <path d="M324,234 C330,236 336,233 342,229 C348,225 354,229 360,231 C364,233 368,230 366,226" stroke-width="1.1"/>
              <g fill="currentColor" opacity="0.15" stroke-width="0.5">
                <path d="M62,231 C58,237 50,239 46,235 C44,232 46,228 50,227Z"/>
                <path d="M110,232 C106,238 98,240 94,236 C92,233 94,229 98,228Z"/>
                <path d="M158,233 C154,239 146,240 142,237 C140,234 142,230 146,229Z"/>
                <path d="M256,234 C252,240 244,240 240,237 C238,234 240,230 244,229Z"/>
                <path d="M306,233 C302,239 294,240 290,237 C288,234 290,230 294,229Z"/>
              </g>
              <!-- Left edge scrollwork -->
              <path d="M14,35 C8,40 10,46 14,52 C17,56 13,60 9,64 C5,68 4,74 7,80 C10,86 16,86 19,82" stroke-width="1.1"/>
              <path d="M7,80 C5,86 7,92 11,98 C15,104 11,110 7,116 C3,122 4,128 7,134 C10,140 16,140 19,136" stroke-width="1.1"/>
              <path d="M7,134 C5,140 7,146 11,152 C15,158 11,164 7,170 C3,176 4,182 7,188 C10,194 16,194 19,190" stroke-width="1.1"/>
              <path d="M7,188 C5,194 9,200 14,206 C17,210 13,214 9,218 C7,220 10,224 14,222" stroke-width="1.1"/>
              <g fill="currentColor" opacity="0.15" stroke-width="0.5">
                <path d="M9,64 C3,60 1,52 5,48 C8,46 12,48 13,52Z"/>
                <path d="M7,116 C1,112 0,104 3,100 C6,98 10,100 11,104Z"/>
                <path d="M7,170 C1,166 0,158 3,154 C6,152 10,154 11,158Z"/>
              </g>
              <!-- Right edge scrollwork -->
              <path d="M386,35 C392,40 390,46 386,52 C383,56 387,60 391,64 C395,68 396,74 393,80 C390,86 384,86 381,82" stroke-width="1.1"/>
              <path d="M393,80 C395,86 393,92 389,98 C385,104 389,110 393,116 C397,122 396,128 393,134 C390,140 384,140 381,136" stroke-width="1.1"/>
              <path d="M393,134 C395,140 393,146 389,152 C385,158 389,164 393,170 C397,176 396,182 393,188 C390,194 384,194 381,190" stroke-width="1.1"/>
              <path d="M393,188 C395,194 391,200 386,206 C383,210 387,214 391,218 C393,220 390,224 386,222" stroke-width="1.1"/>
              <g fill="currentColor" opacity="0.15" stroke-width="0.5">
                <path d="M391,64 C397,60 399,52 395,48 C392,46 388,48 387,52Z"/>
                <path d="M393,116 C399,112 400,104 397,100 C394,98 390,100 389,104Z"/>
                <path d="M393,170 C399,166 400,158 397,154 C394,152 390,154 389,158Z"/>
              </g>
              <!-- Elaborate volute spiral corners -->
              <g stroke-width="0.9">
                <path d="M22,22 C16,16 10,16 8,20 C6,24 10,28 14,28 C18,28 22,24 22,20 C22,16 18,12 14,12 C10,12 6,16 6,20 C6,26 12,32 18,32 C24,32 30,28 30,22 C30,14 24,8 18,8 C12,8 6,12 4,18"/>
                <path d="M378,22 C384,16 390,16 392,20 C394,24 390,28 386,28 C382,28 378,24 378,20 C378,16 382,12 386,12 C390,12 394,16 394,20 C394,26 388,32 382,32 C376,32 370,28 370,22 C370,14 376,8 382,8 C388,8 394,12 396,18"/>
                <path d="M22,218 C16,224 10,224 8,220 C6,216 10,212 14,212 C18,212 22,216 22,220 C22,224 18,228 14,228 C10,228 6,224 6,220 C6,214 12,208 18,208 C24,208 30,212 30,218 C30,226 24,232 18,232 C12,232 6,228 4,222"/>
                <path d="M378,218 C384,224 390,224 392,220 C394,216 390,212 386,212 C382,212 378,216 378,220 C378,224 382,228 386,228 C390,228 394,224 394,220 C394,214 388,208 382,208 C376,208 370,212 370,218 C370,226 376,232 382,232 C388,232 394,228 396,222"/>
              </g>
              <!-- Fleur-de-lis at top center -->
              <g stroke-width="0.7" fill="currentColor" opacity="0.2">
                <path d="M200,1 C197,5 195,9 193,11 C191,13 189,11 189,9 C189,7 191,5 193,3 C195,1 198,0 200,1Z"/>
                <path d="M200,1 C203,5 205,9 207,11 C209,13 211,11 211,9 C211,7 209,5 207,3 C205,1 202,0 200,1Z"/>
                <path d="M200,1 L200,18" fill="none"/>
                <path d="M195,13 C193,15 191,17 193,19 C195,21 197,19 200,16 C203,19 205,21 207,19 C209,17 207,15 205,13"/>
                <circle cx="200" cy="10" r="1.5"/>
              </g>
              <!-- Fleur-de-lis at bottom center -->
              <g stroke-width="0.7" fill="currentColor" opacity="0.2">
                <path d="M200,239 C197,235 195,231 193,229 C191,227 189,229 189,231 C189,233 191,235 193,237 C195,239 198,240 200,239Z"/>
                <path d="M200,239 C203,235 205,231 207,229 C209,227 211,229 211,231 C211,233 209,235 207,237 C205,239 202,240 200,239Z"/>
                <path d="M200,239 L200,222" fill="none"/>
              </g>
              <!-- Fleur-de-lis at side midpoints -->
              <g stroke-width="0.6" fill="currentColor" opacity="0.18">
                <path d="M1,120 C5,117 9,115 11,113 C13,111 11,109 9,109 C7,109 5,111 3,113 C1,115 0,118 1,120Z"/>
                <path d="M1,120 C5,123 9,125 11,127 C13,129 11,131 9,131 C7,131 5,129 3,127 C1,125 0,122 1,120Z"/>
                <path d="M399,120 C395,117 391,115 389,113 C387,111 389,109 391,109 C393,109 395,111 397,113 C399,115 400,118 399,120Z"/>
                <path d="M399,120 C395,123 391,125 389,127 C387,129 389,131 391,131 C393,131 395,129 397,127 C399,125 400,122 399,120Z"/>
              </g>
              <!-- Egg-and-dart molding (top and bottom) -->
              <g stroke-width="0.35" opacity="0.25">
                <ellipse cx="50" cy="24" rx="3.5" ry="2.5"/><line x1="60" y1="21.5" x2="60" y2="26.5"/>
                <ellipse cx="70" cy="24" rx="3.5" ry="2.5"/><line x1="80" y1="21.5" x2="80" y2="26.5"/>
                <ellipse cx="90" cy="24" rx="3.5" ry="2.5"/><line x1="100" y1="21.5" x2="100" y2="26.5"/>
                <ellipse cx="110" cy="24" rx="3.5" ry="2.5"/><line x1="120" y1="21.5" x2="120" y2="26.5"/>
                <ellipse cx="130" cy="24" rx="3.5" ry="2.5"/><line x1="140" y1="21.5" x2="140" y2="26.5"/>
                <ellipse cx="150" cy="24" rx="3.5" ry="2.5"/><line x1="160" y1="21.5" x2="160" y2="26.5"/>
                <ellipse cx="170" cy="24" rx="3.5" ry="2.5"/><line x1="180" y1="21.5" x2="180" y2="26.5"/>
                <ellipse cx="220" cy="24" rx="3.5" ry="2.5"/><line x1="230" y1="21.5" x2="230" y2="26.5"/>
                <ellipse cx="240" cy="24" rx="3.5" ry="2.5"/><line x1="250" y1="21.5" x2="250" y2="26.5"/>
                <ellipse cx="260" cy="24" rx="3.5" ry="2.5"/><line x1="270" y1="21.5" x2="270" y2="26.5"/>
                <ellipse cx="280" cy="24" rx="3.5" ry="2.5"/><line x1="290" y1="21.5" x2="290" y2="26.5"/>
                <ellipse cx="300" cy="24" rx="3.5" ry="2.5"/><line x1="310" y1="21.5" x2="310" y2="26.5"/>
                <ellipse cx="320" cy="24" rx="3.5" ry="2.5"/><line x1="330" y1="21.5" x2="330" y2="26.5"/>
                <ellipse cx="340" cy="24" rx="3.5" ry="2.5"/><line x1="350" y1="21.5" x2="350" y2="26.5"/>
                <ellipse cx="50" cy="216" rx="3.5" ry="2.5"/><line x1="60" y1="213.5" x2="60" y2="218.5"/>
                <ellipse cx="70" cy="216" rx="3.5" ry="2.5"/><line x1="80" y1="213.5" x2="80" y2="218.5"/>
                <ellipse cx="90" cy="216" rx="3.5" ry="2.5"/><line x1="100" y1="213.5" x2="100" y2="218.5"/>
                <ellipse cx="110" cy="216" rx="3.5" ry="2.5"/><line x1="120" y1="213.5" x2="120" y2="218.5"/>
                <ellipse cx="130" cy="216" rx="3.5" ry="2.5"/><line x1="140" y1="213.5" x2="140" y2="218.5"/>
                <ellipse cx="150" cy="216" rx="3.5" ry="2.5"/><line x1="160" y1="213.5" x2="160" y2="218.5"/>
                <ellipse cx="170" cy="216" rx="3.5" ry="2.5"/><line x1="180" y1="213.5" x2="180" y2="218.5"/>
                <ellipse cx="220" cy="216" rx="3.5" ry="2.5"/><line x1="230" y1="213.5" x2="230" y2="218.5"/>
                <ellipse cx="240" cy="216" rx="3.5" ry="2.5"/><line x1="250" y1="213.5" x2="250" y2="218.5"/>
                <ellipse cx="260" cy="216" rx="3.5" ry="2.5"/><line x1="270" y1="213.5" x2="270" y2="218.5"/>
                <ellipse cx="280" cy="216" rx="3.5" ry="2.5"/><line x1="290" y1="213.5" x2="290" y2="218.5"/>
                <ellipse cx="300" cy="216" rx="3.5" ry="2.5"/><line x1="310" y1="213.5" x2="310" y2="218.5"/>
                <ellipse cx="320" cy="216" rx="3.5" ry="2.5"/><line x1="330" y1="213.5" x2="330" y2="218.5"/>
                <ellipse cx="340" cy="216" rx="3.5" ry="2.5"/><line x1="350" y1="213.5" x2="350" y2="218.5"/>
              </g>
              <!-- Cartouche at top center -->
              <g stroke-width="0.7">
                <path d="M188,3 C190,0 196,0 200,0 C204,0 210,0 212,3 C214,6 214,10 212,14 C210,18 206,22 204,24 C202,25 201,26 200,28 C199,26 198,25 196,24 C194,22 190,18 188,14 C186,10 186,6 188,3Z" fill="currentColor" opacity="0.1"/>
                <path d="M188,3 C190,0 196,0 200,0 C204,0 210,0 212,3 C214,6 214,10 212,14 C210,18 206,22 204,24 C202,25 201,26 200,28 C199,26 198,25 196,24 C194,22 190,18 188,14 C186,10 186,6 188,3Z"/>
                <path d="M194,4 C196,8 198,14 200,20" stroke-width="0.3"/><path d="M206,4 C204,8 202,14 200,20" stroke-width="0.3"/>
                <path d="M190,8 C194,10 198,14 200,20" stroke-width="0.3"/><path d="M210,8 C206,10 202,14 200,20" stroke-width="0.3"/>
                <path d="M192,14 C196,14 200,16 200,20" stroke-width="0.25"/><path d="M208,14 C204,14 200,16 200,20" stroke-width="0.25"/>
              </g>
              <!-- Decorative rosettes -->
              <g stroke-width="0.4" opacity="0.25">
                <circle cx="38" cy="14" r="4"/><circle cx="38" cy="14" r="2"/><circle cx="38" cy="14" r="0.8" fill="currentColor"/>
                <circle cx="362" cy="14" r="4"/><circle cx="362" cy="14" r="2"/><circle cx="362" cy="14" r="0.8" fill="currentColor"/>
                <circle cx="38" cy="226" r="4"/><circle cx="38" cy="226" r="2"/><circle cx="38" cy="226" r="0.8" fill="currentColor"/>
                <circle cx="362" cy="226" r="4"/><circle cx="362" cy="226" r="2"/><circle cx="362" cy="226" r="0.8" fill="currentColor"/>
              </g>
            </g>
          </svg>
        </div>
        <div class="screen">
          <canvas id="gl" width="1280" height="720"></canvas>
        </div>
      </div>

      <!-- RIGHT RAIL (dynamically populated) -->
      <aside class="rail right" id="railRight"></aside>
    </div>

    <aside class="bottomPanel">
      <div id="toggleContainer" class="toggleContainer">
        <div class="toggleRow" id="toggleRow1"></div>
        <div class="toggleRow row2" id="toggleRow2"></div>
      </div>
      <div class="slidersGroup">
        <div class="vSlider"><label>DCY</label><input id="decayRange" class="range vRange" type="range" min="0" max="1" step="0.01" value="0.98" /></div>
        <div class="vSlider"><label>CHR</label><input id="chromaticRange" class="range vRange" type="range" min="0" max="1" step="0.01" value="0" /></div>
        <div class="vSlider"><label>VIG</label><input id="vignetteRange" class="range vRange" type="range" min="0" max="1" step="0.01" value="0" /></div>
        <div class="vSlider"><label>GRN</label><input id="filmGrainRange" class="range vRange" type="range" min="0" max="0.3" step="0.01" value="0" /></div>
      </div>
      <div class="bottomRightStack">
        <div class="bottomRight">
          <button id="fullscreenBtn" class="presetTrigger iconBtn" title="Fullscreen (Esc to exit)">⛶</button>
          <button id="uiHideBtn" class="presetTrigger iconBtn" title="Hide UI (keyboard still active)">◎</button>
          <button id="libraryTrigger" class="presetTrigger">LIBRARY</button>
          <button id="skinTrigger" class="presetTrigger">SKINS</button>
          <button id="presetTrigger" class="presetTrigger">PRESETS</button>
        </div>
        <div class="resRow">
          <span class="resLabel">Res</span>
          <button id="res720" class="sourceBtn" type="button">720p</button>
          <button id="res1080" class="sourceBtn on" type="button">1080p</button>
          <button id="res4k" class="sourceBtn" type="button">4K</button>
        </div>
      </div>
    </aside>

    <!-- SKIN OVERLAY -->
    <div id="skinOverlay" class="skinOverlay">
      <div class="skinPanel">
        <div class="skinPanelHeader">
          <div class="skinPanelTitle">SKINS</div>
          <button id="skinClose" class="presetTrigger" style="padding:4px 10px;font-size:9px;">ESC TO CLOSE</button>
        </div>
        <div class="skinGrid">
          <div class="skinCard active" data-skin="default">Default</div>
          <div class="skinCard" data-skin="cybersigilism">Cybersigilism</div>
          <div class="skinCard" data-skin="fantasy">Fantasy</div>
          <div class="skinCard" data-skin="anime">Anime</div>
          <div class="skinCard" data-skin="futuristic">Futuristic</div>
          <div class="skinCard" data-skin="renaissance">Renaissance</div>
          <div class="skinCard cse-create" id="cseCreateBtn">+ Create</div>
        </div>
        <div id="customSkinCards"></div>
        <div class="skinColors">
          <div class="skinColorRow">
            <label>Primary (surfaces)</label>
            <input id="skinPrimaryColor" type="color" value="#0e1219" title="Primary = panel/button/knob color" />
          </div>
          <div class="skinColorRow">
            <label>Third (accent)</label>
            <input id="skinThirdColor" type="color" value="#00d4ff" title="Third = accents, highlights" />
          </div>
          <div class="skinColorRow" style="align-items:center;">
            <label>Depth</label>
            <select id="skinDepth" style="padding:6px 10px;border-radius:6px;border:1px solid var(--skin-panel-border);background:var(--skin-primary);color:var(--skin-ink);font-size:10px;">
              <option value="shadows">Shadows only</option>
              <option value="blend">Color blend</option>
            </select>
          </div>
          <button id="skinResetColors" class="presetTrigger" style="margin-left:8px;padding:6px 12px;font-size:10px;">Reset to preset</button>
        </div>
      </div>
    </div>

    <!-- CUSTOM SKIN EDITOR (floating panel) -->
    <div id="csePanel" class="cse-panel">
      <div class="cse-top-bar">
        <div class="cse-title">SKIN BUILDER</div>
        <button id="cseClose" class="cse-close">CANCEL</button>
      </div>
      <div class="cse-section">
        <div class="cse-section-label">Name</div>
        <div class="cse-row">
          <input type="text" id="cseName" placeholder="My Custom Skin" maxlength="32" style="min-width:0;flex:1;"/>
        </div>
      </div>
      <div class="cse-section">
        <div class="cse-section-label">Colors</div>
        <div class="cse-row">
          <label>Surface</label>
          <input type="color" id="csePrimary" value="#0e1219"/>
        </div>
        <div class="cse-row">
          <label>Accent</label>
          <input type="color" id="cseAccent" value="#7c5cff"/>
        </div>
        <div class="cse-row">
          <label>Opacity</label>
          <input type="range" id="cseSurfaceAlpha" min="0" max="100" value="85"/>
          <span id="cseSurfaceAlphaVal" style="font-size:10px;color:#8b94a5;min-width:28px;text-align:right;">85%</span>
        </div>
      </div>
      <div class="cse-section">
        <div class="cse-section-label">Texture</div>
        <div class="cse-row">
          <label>Type</label>
          <select id="cseTextureType">
            <option value="none">None</option>
            <option value="grain">Grain</option>
            <option value="paper">Paper</option>
            <option value="dither">Dither</option>
            <option value="canvas">Canvas</option>
            <option value="static">Static</option>
            <option value="crosshatch">Crosshatch</option>
          </select>
        </div>
        <div class="cse-row">
          <label>Strength</label>
          <input type="range" id="cseTextureOpacity" min="0" max="100" value="5"/>
          <span id="cseTextureOpacityVal" style="font-size:10px;color:#8b94a5;min-width:28px;text-align:right;">5%</span>
        </div>
        <div class="cse-row">
          <label>Blend</label>
          <select id="cseBlendMode">
            <option value="overlay">Overlay</option>
            <option value="multiply">Multiply</option>
            <option value="screen">Screen</option>
            <option value="soft-light">Soft Light</option>
            <option value="color-burn">Color Burn</option>
            <option value="hard-light">Hard Light</option>
          </select>
        </div>
      </div>
      <div class="cse-section">
        <div class="cse-section-label">Images</div>
        <button class="cse-btn" id="csePngUpload">+ Upload Image</button>
        <input type="file" id="csePngInput" accept="image/*" style="display:none;" multiple/>
        <div class="cse-layer-list" id="cseLayers"></div>
      </div>
      <div class="cse-section">
        <div class="cse-section-label">Custom Knobs</div>
        <div class="cse-row">
          <button class="cse-btn" id="cseKnobUpload" style="flex:1;">Upload Knob</button>
          <div class="cse-knob-preview" id="cseKnobPreview"></div>
          <input type="file" id="cseKnobInput" accept="image/*" style="display:none;"/>
        </div>
        <button class="cse-btn cse-btn-danger" id="cseKnobClear" style="font-size:9px;padding:5px 10px;">Clear Knob</button>
      </div>
      <div class="cse-actions">
        <button class="cse-btn" id="cseCancelBtn">Cancel</button>
        <button class="cse-btn cse-btn-primary" id="cseSaveBtn">Save Skin</button>
      </div>
    </div>

    <!-- LIBRARY OVERLAY -->
    <div id="libOverlay" class="libOverlay">
      <div class="libPanel">
        <div class="libHeader">
          <div class="libTitle">EFFECT LIBRARY</div>
          <div class="libTabs">
            <button class="libTab active" id="libTabKnobs">KNOBS</button>
            <button class="libTab" id="libTabEffects">EFFECTS</button>
          </div>
          <button id="libClose" class="presetTrigger" style="padding:4px 10px;font-size:9px;">ESC TO CLOSE</button>
        </div>
        <div class="libBody" id="libBody"></div>
      </div>
    </div>

    <!-- PRESET POPUP -->
    <div id="presetOverlay" class="presetOverlay">
      <div class="presetPanel">
        <div class="presetHeader">
          <div class="presetTitle">PRESET SCENES</div>
          <button id="presetClose" class="presetTrigger" style="padding:4px 10px;font-size:9px;">ESC TO CLOSE</button>
        </div>
        <div class="presetGrid">
          <div class="preset" data-preset="reset">Reset</div>
          <div class="preset" data-preset="neon">Neon Storm</div>
          <div class="preset" data-preset="databend">Databend</div>
          <div class="preset" data-preset="vhs">VHS Inferno</div>
          <div class="preset" data-preset="monochrome">Monochrome Noir</div>
          <div class="preset" data-preset="ocean">Oceanic</div>
          <div class="preset" data-preset="cinematic">Cinematic</div>
        </div>
      </div>
    </div>

  </div>

<script>
(async function(){
  const AUTH_CONFIG = window.__GLITCHLAB_AUTH__ || { enabled: false, supabaseUrl: '', supabaseAnonKey: '', requireAuth: false };
  let hasAccess = true;

  const canvas = document.getElementById('gl');
  const gl = canvas.getContext('webgl2', {alpha:false, antialias:false});
  if(!gl){ alert('WebGL2 required (Chrome/Edge).'); return; }

  // --- Video source: camera or upload ---
  const video = document.createElement('video');
  video.autoplay = true; video.playsInline = true; video.muted = true;
  const uploadVideo = document.createElement('video');
  uploadVideo.autoplay = true; uploadVideo.playsInline = true; uploadVideo.muted = false; uploadVideo.loop = true;
  uploadVideo.setAttribute('playsinline', '');
  uploadVideo.style.cssText = 'position:absolute;width:0;height:0;opacity:0;pointer-events:none;';
  let hasStream = false;
  let useUpload = false;
  let uploadObjectURL = null;
  let cameraStream = null;
  let audioMode = 'video';
  try{
    const s = await navigator.mediaDevices.getUserMedia({video:{width:1280,height:720,facingMode:'user'}, audio:true});
    cameraStream = s; video.srcObject = s; await video.play(); hasStream = true;
  }catch(e){
    console.warn('[VideoSynth] Camera error', e);
    alert('Camera denied/unavailable. Use HTTPS (or localhost) and allow access.');
  }
  let audioContext = null;
  let analyser = null;
  let waveformData = null;
  let audioLevel = 0;
  if(cameraStream){
    try{
      const ac = new (window.AudioContext || window.webkitAudioContext)();
      audioContext = ac;
      const an = ac.createAnalyser();
      an.fftSize = 256;
      an.smoothingTimeConstant = 0.7;
      an.minDecibels = -60;
      an.maxDecibels = -10;
      const src = ac.createMediaStreamSource(cameraStream);
      src.connect(an);
      analyser = an;
      waveformData = new Uint8Array(256);
    }catch(err){ console.warn('[VideoSynth] Audio analyser failed', err); }
  }
  function getVideoSource(){ return useUpload ? uploadVideo : video; }
  function hasVideoFrame(){
    if(useUpload) return uploadVideo.readyState >= 2;
    return hasStream && video.readyState >= 2;
  }

  // --- GL setup ---
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
  const vs = `#version 300 es
 in vec2 a_pos; out vec2 v_uv;
 void main(){ v_uv=a_pos*0.5+0.5; gl_Position=vec4(a_pos,0.0,1.0); }`;

  const fs = `#version 300 es
 precision highp float;
 uniform sampler2D u_tex;
 uniform sampler2D u_feedback;
 uniform vec2 u_res;
 uniform vec2 u_texRes;
 uniform float u_time;
 // -- knob uniforms (float) --
 uniform float u_glitch;
 uniform float u_pixel;
 uniform float u_rgb;
 uniform float u_noise;
 uniform float u_feedbackAmt;
 uniform float u_decay;
 uniform float u_sat;
 uniform float u_bright;
 uniform float u_contrast;
 uniform float u_bloom;
 uniform float u_swirl;
 uniform float u_ripple;
 uniform float u_warp;
 uniform float u_poster;
 uniform float u_hue;
 uniform float u_palette;
 uniform float u_tempo;
 uniform float u_chaos;
 uniform float u_zoom;
 uniform float u_frameRotate;
 uniform float u_tile;
 uniform float u_barrel;
 uniform float u_turbulence;
 uniform float u_drift;
 uniform float u_fractal;
 uniform float u_temperature;
 uniform float u_vibrance;
 uniform float u_gamma;
 uniform float u_threshold;
 uniform float u_tint;
 uniform float u_duotone;
 uniform float u_echo;
 uniform float u_speed;
 uniform float u_halftone;
 uniform float u_emboss;
 uniform float u_sharpen;
 uniform float u_blur;
 uniform float u_dither;
 uniform float u_vhsWobble;
 uniform float u_morph;
 uniform float u_waveSlice;
 uniform float u_crystal;
 uniform float u_foldAmt;
 uniform float u_contour;
 // -- toggle uniforms (int) --
 uniform int u_displace;
 uniform int u_scan;
 uniform int u_invert;
 uniform int u_strobe;
 uniform int u_mirror;
 uniform int u_edge;
 uniform int u_solar;
 uniform int u_slit;
 uniform int u_kaleido;
 uniform int u_mosh;
 uniform int u_vector;
 uniform int u_scope;
 uniform int u_pulse;
 uniform int u_rhythm;
 uniform int u_thermal;
 uniform int u_nightVis;
 uniform int u_prism;
 uniform int u_freeze;
 uniform int u_stutter;
 uniform int u_pixelSort;
 uniform int u_glitchBlocks;
 uniform int u_staticTV;
 uniform int u_rainbowWash;
 uniform int u_zoomBlur;
 uniform int u_spinBlur;
 uniform int u_crossProcess;
 uniform int u_colorNeg;
 uniform int u_tile4x;
 uniform int u_filmBurn;
 uniform int u_bitCrush;
 uniform int u_liquid;
 uniform int u_tunnel;
 uniform int u_shatter;
 uniform int u_holo;
 uniform int u_plasma;
 uniform int u_echo3d;
 uniform int u_sineSlice;
 uniform int u_refract;
 uniform int u_fold;
 uniform int u_reaction;
 uniform int u_conway;
 uniform int u_fractalMap;
 uniform int u_xorMelt;
 uniform int u_phaseWarp;
 uniform int u_topo;
 uniform int u_smear;
 uniform int u_datamosh;
 uniform int u_automata;
 uniform int u_strange;
 uniform int u_tessellate;
 uniform int u_delta;
 uniform int u_interference;
 uniform int u_shred;
 uniform int u_corrupt;
 uniform int u_ringMod;
 uniform int u_overflow;
 uniform int u_recurse;
 uniform int u_glitchDNA;
 uniform int u_logistic;
 uniform int u_hashMelt;
 uniform int u_mirrorFold;
 uniform int u_powerCrush;
 uniform int u_staircase;
 uniform int u_digit;
 // -- LFO uniforms --
 uniform float u_g_rate; uniform float u_g_depth; uniform int u_g_wave; uniform float u_g_seed;
 uniform float u_p_rate; uniform float u_p_depth; uniform int u_p_wave; uniform float u_p_seed;
 uniform float u_r_rate; uniform float u_r_depth; uniform int u_r_wave; uniform float u_r_seed;
 uniform float u_f_rate; uniform float u_f_depth; uniform int u_f_wave; uniform float u_f_seed;
 uniform float u_h_rate; uniform float u_h_depth; uniform int u_h_wave; uniform float u_h_seed;
 uniform float u_pal_rate; uniform float u_pal_depth; uniform int u_pal_wave; uniform float u_pal_seed;
 in vec2 v_uv;
 out vec4 outCol;

 float hash(float n){ return fract(sin(n)*43758.5453123); }
 float rand(vec2 c){ return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453); }
 float vnoise(vec2 p){
   vec2 i=floor(p), f=fract(p); f=f*f*(3.0-2.0*f);
   float a=hash(i.x+i.y*57.0), b=hash(i.x+1.0+i.y*57.0);
   float c=hash(i.x+(i.y+1.0)*57.0), d=hash(i.x+1.0+(i.y+1.0)*57.0);
   return mix(mix(a,b,f.x), mix(c,d,f.x), f.y);
 }
 float fbm(vec2 p){
   float s=0.0, a=0.5;
   for(int i=0;i<4;i++){ s+=a*vnoise(p); p*=2.02; a*=0.5; }
   return s;
 }
 float wave(float t,float r,int ty){
   float x=t*max(r,0.0001);
   if(ty==0) return 0.5+0.5*sin(6.28318*x);
   if(ty==1){ float f=fract(x); return 1.0-abs(2.0*f-1.0); }
   if(ty==2) return step(0.5,fract(x));
   return hash(floor(x*8.0));
 }
 float chaos(float t,float rate,int type,float seed){
   if(rate==0.0) return 0.0;
   vec2 p=vec2(t*rate*0.35+seed, t*rate*0.27+seed*1.7);
   float n=fbm(p+vec2(fbm(p+3.1), fbm(p+7.7)));
   float hold=mix(0.05,0.6,hash(floor(t*rate*0.5+seed*9.0)));
   float s=wave(floor(t/hold)*hold, rate*0.3, 3);
   float u=fract(t*rate*0.8+seed*0.3);
   float logistic=4.0*u*(1.0-u);
   float base=mix(wave(t,rate,type), n, 0.75);
   float m=mix(base, logistic, 0.25);
   float spike=step(0.97, rand(vec2(t*rate*0.9+seed, seed*13.0)));
   return clamp(m+spike*0.35+s*0.15,0.0,1.0);
 }
 vec2 contain(vec2 uv, vec2 res, vec2 texRes){
   float tex=texRes.x/texRes.y, can=res.x/res.y;
   if(can>tex){ float sc=tex/can, pad=(1.0-sc)*0.5; uv.x=(uv.x-pad)/sc; }
   else { float sc=can/tex, pad=(1.0-sc)*0.5; uv.y=(uv.y-pad)/sc; }
   return clamp(uv,0.0,1.0);
 }
 vec2 pixelate(vec2 uv,float px){
   if(px<=1.0) return uv;
   vec2 p=floor(uv*u_res/px)+0.5; return p*px/u_res;
 }
 vec3 hueShift(vec3 c,float a){
   float ca=cos(a), sa=sin(a);
   mat3 R=mat3(
     0.299+0.701*ca+0.168*sa, 0.587-0.587*ca+0.330*sa, 0.114-0.114*ca-0.497*sa,
     0.299-0.299*ca-0.328*sa, 0.587+0.413*ca+0.035*sa, 0.114-0.114*ca+0.292*sa,
     0.299-0.300*ca+1.250*sa, 0.587-0.588*ca-1.050*sa, 0.114+0.886*ca-0.203*sa);
   return clamp(R*c,0.0,1.0);
 }
 vec3 paletteCos(vec3 c,float a){
   float l=dot(c,vec3(0.299,0.587,0.114));
   vec3 pal=0.5+0.5*cos(6.28318*(vec3(l,l+0.33,l+0.67))+vec3(0.0,2.0,4.0));
   return mix(c,pal,a);
 }

 void main(){
   float tBase=u_time;
   float t=tBase*(0.5 + u_tempo*2.0)*(0.2 + u_speed*2.8);

   float MG=u_g_depth*chaos(t,u_g_rate,u_g_wave,u_g_seed);
   float MP=u_p_depth*chaos(t,u_p_rate,u_p_wave,u_p_seed);
   float MR=u_r_depth*chaos(t,u_r_rate,u_r_wave,u_r_seed);
   float MF=u_f_depth*chaos(t,u_f_rate,u_f_wave,u_f_seed);
   float MH=u_h_depth*chaos(t,u_h_rate,u_h_wave,u_h_seed);
   float MPL=u_pal_depth*chaos(t,u_pal_rate,u_pal_wave,u_pal_seed);

   vec2 uv=contain(v_uv,u_res,u_texRes);

   // -- chaos: stochastic UV disruption --
   if(u_chaos > 0.01){
     float cN = fbm(uv*8.0 + t*u_chaos*2.0);
     float cSpike = step(0.97, rand(vec2(floor(uv.y*60.0), floor(t*u_chaos*5.0))));
     uv += (vec2(cN, fbm(uv*8.0+100.0+t)) - 0.5) * u_chaos * 0.06;
     uv += cSpike * vec2((rand(vec2(t,uv.y*99.0))-0.5)*0.12, 0.0) * u_chaos;
   }

   // -- NEW: zoom --
   if(u_zoom > 0.001){
     uv = (uv - 0.5) / (1.0 + u_zoom * 4.0) + 0.5;
   }
   // -- NEW: frame rotate --
   if(abs(u_frameRotate) > 0.001){
     vec2 rc = uv - 0.5;
     float ra = u_frameRotate * 6.28318;
     uv = vec2(rc.x*cos(ra)-rc.y*sin(ra), rc.x*sin(ra)+rc.y*cos(ra)) + 0.5;
   }
   // -- NEW: tile --
   if(u_tile > 0.001){
     uv = fract(uv * (1.0 + u_tile * 7.0));
   }
   // -- NEW: barrel distortion --
   if(abs(u_barrel) > 0.001){
     vec2 bc = uv - 0.5;
     float br2 = dot(bc, bc);
     uv = bc * (1.0 + u_barrel * br2 * 3.0) + 0.5;
   }
   // -- NEW: drift --
   if(u_drift > 0.001){
     uv.x += sin(tBase*0.2)*u_drift*0.1;
     uv.y += cos(tBase*0.15)*u_drift*0.08;
   }
   // -- NEW: turbulence --
   if(u_turbulence > 0.001){
     vec2 tn=vec2(fbm(uv*4.0+t*0.3), fbm(uv*4.0+t*0.4+10.0));
     uv += (tn-0.5)*u_turbulence*0.15;
   }

   // -- PHASE WARP: feedback luminance drives UV vortices --
   if(u_phaseWarp==1){
     vec3 pwFB = texture(u_feedback, uv).rgb;
     float pwLuma = dot(pwFB, vec3(0.299,0.587,0.114));
     float pwAng = pwLuma * 6.28318 + t*1.5;
     float pwStr = (pwLuma - 0.5) * 0.04;
     uv += vec2(cos(pwAng), sin(pwAng)) * pwStr;
     vec3 pwFB2 = texture(u_feedback, uv + vec2(0.01,0.0)).rgb;
     float pwL2 = dot(pwFB2, vec3(0.299,0.587,0.114));
     uv += vec2(pwLuma - pwL2, pwL2 - pwLuma) * 0.03;
   }
   // -- FRACTAL MAP: Julia set iteration on UV --
   if(u_fractalMap==1){
     vec3 fmFB = texture(u_feedback, v_uv).rgb;
     float fmL = dot(fmFB, vec3(0.299,0.587,0.114));
     vec2 fmZ = (uv - 0.5) * 2.5;
     vec2 fmC = vec2(-0.7 + sin(t*0.3)*0.2, 0.27 + cos(t*0.4)*0.15);
     fmC += (fmFB.rg - 0.5) * 0.3;
     for(int i=0; i<3; i++){
       fmZ = vec2(fmZ.x*fmZ.x - fmZ.y*fmZ.y, 2.0*fmZ.x*fmZ.y) + fmC;
       if(dot(fmZ,fmZ) > 4.0) break;
     }
     vec2 fmUV = fmZ * 0.2 + 0.5;
     fmUV = clamp(fmUV, 0.0, 1.0);
     uv = mix(uv, fmUV, 0.35);
   }
   // -- TESSELLATE: voronoi feedback remapping --
   if(u_tessellate==1){
     vec2 tsCell = floor(uv * 6.0);
     vec2 tsFract = fract(uv * 6.0);
     float tsLuma = dot(texture(u_feedback, (tsCell+0.5)/6.0).rgb, vec3(0.299,0.587,0.114));
     float tsAng = tsLuma * 6.2832 + t;
     mat2 tsRot = mat2(cos(tsAng), -sin(tsAng), sin(tsAng), cos(tsAng));
     vec2 tsOff = (tsFract - 0.5) * tsRot * (0.6 + tsLuma*0.4) + 0.5;
     vec2 tsUV = (tsCell + tsOff) / 6.0;
     tsUV = clamp(tsUV, 0.0, 1.0);
     uv = mix(uv, tsUV, 0.5);
   }

   // -- LIQUID: fluid dynamics displacement --
   if(u_liquid==1){
     float lT = t*0.6;
     vec2 lP = uv*3.0;
     float l1 = fbm(lP + vec2(lT*0.4, lT*0.3));
     float l2 = fbm(lP + vec2(-lT*0.35, lT*0.45) + 5.0);
     float l3 = fbm(vec2(l1, l2)*2.0 + lT*0.2);
     vec2 lFlow = vec2(l1 - 0.5 + l3*0.3, l2 - 0.5 + l3*0.3);
     float lPulse = 0.7 + 0.3*sin(t*1.2);
     uv += lFlow * 0.07 * lPulse;
   }
   // -- MORPH: organic morphing displacement --
   if(u_morph > 0.001){
     float mT = t*0.4;
     float m1 = fbm(uv*5.0 + vec2(mT, -mT*0.7));
     float m2 = fbm(uv*5.0 + vec2(-mT*0.6, mT*0.9) + 7.0);
     float m3 = fbm(vec2(m1*3.0, m2*3.0) + mT*0.3);
     uv += vec2(m1-0.5, m2-0.5) * u_morph * 0.12 * (0.5 + m3);
   }
   // -- WAVE SLICE: sine wave displacement --
   if(u_waveSlice > 0.001){
     float wFreq = 8.0 + u_waveSlice*25.0;
     float wAmp = u_waveSlice*0.04;
     uv.x += sin(uv.y*wFreq + t*4.0)*wAmp;
     uv.y += cos(uv.x*wFreq*0.7 + t*3.0)*wAmp*0.6;
   }
   // -- CRYSTAL: voronoi tessellation --
   if(u_crystal > 0.001){
     float crScale = 4.0 + u_crystal*12.0;
     vec2 crCell = floor(uv*crScale);
     vec2 crF = fract(uv*crScale);
     float crMin = 1.0;
     vec2 crOff = vec2(0.0);
     for(int cy=-1;cy<=1;cy++){
       for(int cx=-1;cx<=1;cx++){
         vec2 cn = vec2(float(cx),float(cy));
         vec2 cp = vec2(rand(crCell+cn), rand(crCell+cn+99.0));
         cp = 0.5 + 0.4*sin(t*0.5 + 6.28318*cp);
         float cd = length(cn + cp - crF);
         if(cd < crMin){ crMin = cd; crOff = (cn + cp - crF); }
       }
     }
     uv += crOff * 0.015 * u_crystal;
   }
   // -- SHATTER: animated glass break --
   if(u_shatter==1){
     float shScale = 6.0;
     vec2 shCell = floor(uv*shScale);
     vec2 shF = fract(uv*shScale);
     float shN = rand(shCell + floor(t*2.0));
     float shAng = shN*6.28318 + t*2.0;
     float shMag = step(0.7, shN) * 0.04;
     uv += vec2(cos(shAng), sin(shAng)) * shMag;
     float shEdge = min(min(shF.x, 1.0-shF.x), min(shF.y, 1.0-shF.y));
     if(shEdge < 0.04) uv += (vec2(rand(shCell+t), rand(shCell*2.0+t))-0.5)*0.02;
   }
   // -- SINE SLICE: strip displacement --
   if(u_sineSlice==1){
     float sliceH = 0.03 + 0.02*sin(t*0.7);
     float sliceId = floor(uv.y / sliceH);
     float slicePhase = sliceId*0.8 + t*3.0;
     float sliceAmt = sin(slicePhase)*0.035 * (0.5 + 0.5*sin(t*1.3+sliceId*0.5));
     uv.x += sliceAmt;
     float sliceGap = abs(fract(uv.y/sliceH) - 0.5)*2.0;
     if(sliceGap > 0.94) uv.x += (rand(vec2(sliceId, t))-0.5)*0.08;
   }
   // -- REFRACT: light through moving liquid surface --
   if(u_refract==1){
     float rT = t*0.8;
     float rN1 = fbm(uv*6.0 + vec2(rT*0.5, rT*0.3));
     float rN2 = fbm(uv*6.0 + vec2(-rT*0.4, rT*0.6) + 3.0);
     vec2 rNormal = vec2(
       fbm(uv*8.0 + vec2(rT*0.7, 0.0)) - fbm(uv*8.0 + vec2(rT*0.7+0.01, 0.0)),
       fbm(uv*8.0 + vec2(0.0, rT*0.5)) - fbm(uv*8.0 + vec2(0.0, rT*0.5+0.01))
     );
     uv += rNormal * 3.0 * (0.7 + 0.3*sin(t*0.4));
   }

   // -- existing geometric --
   vec2 p = uv - 0.5;
   float r = length(p);
   float th = atan(p.y,p.x);
   th += u_swirl * (0.6 - r) * 2.5;
   p = vec2(cos(th), sin(th)) * r;
   p += normalize(p+1e-5) * (sin(r*40.0+t*8.0)*0.002*u_ripple);
   p *= (1.0 + u_warp*r*r*1.8);
   vec2 uvG = p + 0.5;
   if(u_mirror==1) uvG.x = (uvG.x>0.5) ? 1.0-uvG.x : uvG.x;
   uv = clamp(uvG,0.0,1.0);

   if(u_kaleido==1){
     vec2 kc=uv-0.5; float kr=length(kc); float ka=atan(kc.y,kc.x);
     float seg=8.0, slice=6.28318/seg;
     ka=mod(ka,slice); if(ka>slice*0.5) ka=slice-ka;
     uv=clamp(vec2(cos(ka),sin(ka))*kr+0.5, 0.0, 1.0);
   }

   // -- NEW: tile 4x toggle --
   if(u_tile4x==1) uv = fract(uv * 4.0);

   float motion=clamp(MG+MR,0.0,1.0);
   vec2 n2=vec2(fbm(uv*6.0+vec2(t*0.6+u_g_seed,-t*0.5+u_r_seed)),
                fbm(uv*6.0+vec2(-t*0.4+u_p_seed,t*0.7+u_f_seed)));
   uv += (n2-0.5)*(0.12*motion);

   // -- NEW: vhs wobble --
   if(u_vhsWobble > 0.001){
     float vhsY = uv.y + sin(t*4.0+uv.y*20.0)*u_vhsWobble*0.005;
     uv.x += (rand(vec2(floor(vhsY*100.0),t))-0.5)*u_vhsWobble*0.015;
     uv.y = vhsY;
   }

   float px=u_pixel+(MP)*50.0;
   uv=pixelate(uv,px);

   // -- freeze: use feedback only --
   if(u_freeze==1){
     outCol=vec4(texture(u_feedback,v_uv).rgb,1.0); return;
   }

   vec3 vid=texture(u_tex,uv).rgb;

   // -- stutter --
   if(u_stutter==1){
     float stOn=step(0.5, fract(floor(t*4.0)*0.5));
     vid=mix(texture(u_feedback,v_uv).rgb, vid, stOn);
   }

   if(u_slit==1){
     vec2 su=vec2(mod(v_uv.x+t*0.05,1.0), v_uv.y);
     vid=mix(vid, texture(u_feedback,su).rgb, 0.6);
   }

   float fbmw=fbm(uv*3.0+vec2(t*0.3,-t*0.25));
   float rgbAmt=u_rgb+MR;
   float off2=rgbAmt*0.05*(0.5+fbmw);
   float r1=texture(u_tex,uv+vec2(off2,0.0)).r;
   float g1=texture(u_tex,uv+vec2(0.0,off2*0.6)).g;
   float b1=texture(u_tex,uv-vec2(off2,0.0)).b;
   vec3 col=mix(vid,vec3(r1,g1,b1),clamp(rgbAmt,0.0,1.0));

   if(u_displace==1){
     vec2 jitter=(vec2(rand(uv+t),rand(uv*1.7-t))-0.5)*(0.08+(MR)*0.12);
     col=mix(col,texture(u_tex,uv+jitter).rgb,0.7);
   }

   float gAmt=clamp(u_glitch+MG,0.0,1.0);
   if(gAmt>0.001){
     for(int i=0;i<3;i++){
       float band=step(0.98-float(i)*0.01, rand(vec2(floor(uv.y*float(80+i*30))+t*float(1+i), float(i)*7.0)));
       if(band>0.5){
         float dir=(rand(vec2(t*3.0+float(i),uv.y*99.0))>0.5)?1.0:-1.0;
         float amp=gAmt*(0.02+0.15*rand(vec2(uv.y*333.0+float(i),t*2.0)));
         col=texture(u_tex, clamp(uv+vec2(dir*amp,0.0), 0.0, 1.0)).rgb;
       }
     }
     vec2 d=(vec2(rand(uv+t),rand(uv*2.0-t))-0.5)*(gAmt*0.02);
     col=mix(col,texture(u_tex,uv+d).rgb,0.5);
   }

   col += (rand(uv*(1.0+t*0.3))-0.5)*(u_noise+(MG)*0.3)*0.5;

   // -- NEW: glitch blocks --
   if(u_glitchBlocks==1){
     vec2 gbId=floor(v_uv*vec2(u_res.x/32.0,u_res.y/32.0));
     float gbR=rand(gbId+floor(t*3.0));
     if(gbR>0.92){
       vec2 gbOff=(vec2(rand(gbId*3.0+t),rand(gbId*7.0+t))-0.5)*0.15;
       col=texture(u_tex, clamp(uv+gbOff,0.0,1.0)).rgb;
     }
   }
   // -- NEW: pixel sort --
   if(u_pixelSort==1){
     float psL=dot(col,vec3(0.299,0.587,0.114));
     if(psL>0.3) col=texture(u_tex, vec2(uv.x+psL*0.05, uv.y)).rgb;
   }
   // -- NEW: static TV --
   if(u_staticTV==1){
     col=mix(col, vec3(rand(uv*800.0+t*100.0)), 0.6);
   }

   if(u_vector==1){
     vec2 vc=v_uv-0.5; float rr=length(vc); float aa=atan(vc.y,vc.x);
     float arms=5.0, seg2=6.28318/arms;
     float aFold=mod(aa+0.3*sin(t*0.3), seg2);
     if(aFold>seg2*0.5) aFold=seg2-aFold;
     float ring=sin(rr*40.0-t*6.0)*0.03, twist=sin(rr*6.0-t*2.0)*0.5;
     vec2 warp1=vec2(cos(aFold+twist),sin(aFold+twist))*(rr+ring);
     vec2 warp2=warp1*(0.7+0.2*sin(t*0.4));
     vec2 cd=vec2(0.5+0.18*sin(t*0.21),0.5+0.18*cos(t*0.19));
     vec3 s1=texture(u_tex, clamp(warp1+0.5,0.0,1.0)).rgb;
     vec3 s2=texture(u_feedback, clamp(warp2+cd,0.0,1.0)).rgb;
     vec3 vortexCol=mix(s1,s2,0.6);
     float fade=smoothstep(0.0,0.9,rr);
     col=mix(col, mix(vortexCol,col,fade*0.2), 0.9);
   }

   if(u_scan==1){
     float scan=sin((v_uv.y*u_res.y)*(1.0+(MR)*6.0)+t*60.0);
     col*=mix(1.0, scan*0.55+0.45, 0.7);
   }
   if(u_strobe==1) col*=mix(1.0,0.15,step(0.5,fract(t*(2.0+(MG)*12.0))));

   // -- NEW: zoom blur --
   if(u_zoomBlur==1){
     vec2 zbDir=v_uv-0.5; vec3 zbCol=col;
     for(int i=1;i<6;i++) zbCol+=texture(u_tex, uv-zbDir*float(i)*0.012).rgb;
     col=zbCol/6.0;
   }
   // -- NEW: spin blur --
   if(u_spinBlur==1){
     vec2 sbC=v_uv-0.5; float sbR=length(sbC); float sbA=atan(sbC.y,sbC.x);
     vec3 sbCol=col;
     for(int i=1;i<5;i++){
       vec2 sbUV=vec2(cos(sbA+float(i)*0.02),sin(sbA+float(i)*0.02))*sbR+0.5;
       sbCol+=texture(u_tex, clamp(sbUV,0.0,1.0)).rgb;
     }
     col=sbCol/5.0;
   }
   // -- NEW: prism --
   if(u_prism==1){
     float pA=atan(v_uv.y-0.5, v_uv.x-0.5);
     vec2 pDir=vec2(cos(pA),sin(pA))*0.015;
     col.r=texture(u_tex, uv+pDir).r;
     col.b=texture(u_tex, uv-pDir).b;
   }

   // -- color: hue (FIXED - direct + LFO) --
   float hueA = 6.28318 * (u_hue + pow(clamp(MH,0.0,1.0),0.85)*0.65);
   col=hueShift(col,hueA);
   // -- tint --
   if(u_tint > 0.001) col=hueShift(col, u_tint*3.14159);
   // -- palette (FIXED) --
   col=paletteCos(col, clamp(u_palette + MPL*0.6, 0.0, 1.0));

   // -- poster --
   float steps = max(2.0, u_poster);
   col = floor(col*steps)/steps;

   // -- NEW: temperature --
   col.r += u_temperature*0.15;
   col.b -= u_temperature*0.15;
   // -- NEW: vibrance --
   if(u_vibrance>0.001){
     float vAvg=(col.r+col.g+col.b)/3.0;
     col=mix(vec3(vAvg), col, 1.0+u_vibrance*1.5);
   }
   // -- NEW: gamma --
   if(abs(u_gamma-0.5)>0.01) col=pow(max(col,0.0), vec3(0.3+u_gamma*2.4));
   // -- NEW: threshold --
   if(u_threshold>0.01){
     float tLuma=dot(col,vec3(0.299,0.587,0.114));
     col=mix(col, vec3(step(1.0-u_threshold, tLuma)), u_threshold);
   }
   // -- NEW: duotone --
   if(u_duotone>0.01){
     float dtL=dot(col,vec3(0.299,0.587,0.114));
     vec3 dtA=vec3(0.1,0.0,0.3), dtB=vec3(1.0,0.6,0.1);
     col=mix(col, mix(dtA,dtB,dtL), u_duotone);
   }

   float luma=dot(col,vec3(0.299,0.587,0.114));
   col=mix(vec3(luma), col, 0.25+0.7*u_sat);
   col=col+(u_bright-0.5);
   col=(col-0.5)*(0.5+u_contrast*2.0)+0.5;
   col+=smoothstep(0.75,1.0,luma)*u_bloom*0.8;

   // -- NEW: thermal --
   if(u_thermal==1){
     float tL=dot(col,vec3(0.299,0.587,0.114));
     vec3 therm;
     if(tL<0.25) therm=mix(vec3(0.0,0.0,0.5),vec3(0.0,0.8,0.0),tL*4.0);
     else if(tL<0.5) therm=mix(vec3(0.0,0.8,0.0),vec3(1.0,1.0,0.0),(tL-0.25)*4.0);
     else if(tL<0.75) therm=mix(vec3(1.0,1.0,0.0),vec3(1.0,0.0,0.0),(tL-0.5)*4.0);
     else therm=mix(vec3(1.0,0.0,0.0),vec3(1.0),  (tL-0.75)*4.0);
     col=therm;
   }
   // -- NEW: night vision --
   if(u_nightVis==1){
     float nvL=pow(dot(col,vec3(0.299,0.587,0.114)),0.7)*1.3;
     float nvN=rand(uv+t)*0.15;
     col=vec3(nvN*0.3, nvL+nvN, nvN*0.2);
     col*=clamp(1.0-length(v_uv-0.5)*1.2, 0.0, 1.0);
   }
   // -- NEW: cross process --
   if(u_crossProcess==1){
     col=clamp(vec3(pow(col.r,0.8),pow(col.g,1.2),pow(col.b,0.7))*vec3(1.1,0.95,1.15),0.0,1.0);
   }
   // -- NEW: rainbow wash --
   if(u_rainbowWash==1){
     vec3 rb=0.5+0.5*cos(6.28318*(v_uv.x*2.0+v_uv.y+t*0.5+vec3(0.0,0.33,0.67)));
     col=mix(col, col*rb*1.5, 0.4);
   }
   // -- NEW: film burn --
   if(u_filmBurn==1){
     float fbEdge=max(abs(v_uv.x-0.5),abs(v_uv.y-0.5))*2.0;
     float fbN=fbm(vec2(v_uv.x*3.0+t*0.3, v_uv.y*2.0));
     col=mix(col, vec3(1.0,0.6,0.2), smoothstep(0.5,1.0,fbEdge+fbN*0.3)*0.7);
   }

   if(u_edge==1){
     vec2 px2=1.0/u_res;
     vec3 tl=texture(u_tex,uv+px2*vec2(-1,-1)).rgb, tc=texture(u_tex,uv+px2*vec2(0,-1)).rgb;
     vec3 tr=texture(u_tex,uv+px2*vec2(1,-1)).rgb, ml=texture(u_tex,uv+px2*vec2(-1,0)).rgb;
     vec3 mr2=texture(u_tex,uv+px2*vec2(1,0)).rgb, bl=texture(u_tex,uv+px2*vec2(-1,1)).rgb;
     vec3 bc=texture(u_tex,uv+px2*vec2(0,1)).rgb, br=texture(u_tex,uv+px2*vec2(1,1)).rgb;
     vec3 L=vec3(0.2126,0.7152,0.0722);
     float gx=dot(tr,L)+2.0*dot(mr2,L)+dot(br,L)-dot(tl,L)-2.0*dot(ml,L)-dot(bl,L);
     float gy=dot(bl,L)+2.0*dot(bc,L)+dot(br,L)-dot(tl,L)-2.0*dot(tc,L)-dot(tr,L);
     col=mix(col, vec3(clamp(length(vec2(gx,gy))*1.5,0.0,1.0)), 0.6);
   }
   if(u_solar==1) col=1.0-abs(2.0*col-1.0);

   // -- FOLD: multi-pass wave folding --
   if(u_fold==1){
     float folds = 3.0 + u_foldAmt * 3.0;
     col = sin(col * 3.14159 * folds) * 0.5 + 0.5;
     col = sin(col * 3.14159 * folds * 0.7) * 0.5 + 0.5;
     col = sin(col * 3.14159 * folds * 0.5) * 0.5 + 0.5;
   }
   // -- FOLD AMT knob: continuous folding independent of toggle --
   if(u_fold==0 && u_foldAmt>0.01){
     float fa = u_foldAmt * 4.0;
     col = sin(col * 3.14159 * fa) * 0.5 + 0.5;
   }
   // -- STRANGE: Lorenz-like attractor coloring --
   if(u_strange==1){
     vec3 st = col * 2.0 - 1.0;
     float sigma = 10.0, rho = 28.0, beta = 2.667;
     float dt = 0.002;
     float dx = sigma * (st.y - st.x) * dt;
     float dy = (st.x * (rho - st.z) - st.y) * dt;
     float dz = (st.x * st.y - beta * st.z) * dt;
     st += vec3(dx, dy, dz);
     col = st * 0.5 + 0.5;
     col = fract(col * 1.5 + t * 0.05);
   }
   // -- XOR MELT: pseudo-bitwise XOR with feedback --
   if(u_xorMelt==1){
     vec3 xmFB = texture(u_feedback, v_uv).rgb;
     vec3 q1 = floor(col*8.0), q2 = floor(xmFB*8.0);
     vec3 xored = mod(q1+q2, 8.0)/8.0;
     col = mix(col, xored, 0.7);
     col = sin(col * 6.283 * 2.0) * 0.5 + 0.5;
   }
   // -- SHRED: feedback-driven fractional multiplication + tent map --
   if(u_shred==1){
     vec3 shFB = texture(u_feedback, v_uv).rgb;
     vec3 shMul = floor(shFB * 7.0) + 2.0;
     col = fract(col * shMul);
     col = 1.0 - abs(2.0*col - 1.0);
   }
   // -- CORRUPT: cross-channel quantized multiplication cascade --
   if(u_corrupt==1){
     float cR = col.r, cG = col.g, cB = col.b;
     col.r = fract(floor(cR*6.0) * cG * 3.0);
     col.g = fract(floor(cG*6.0) * cB * 3.0);
     col.b = fract(floor(cB*6.0) * cR * 3.0);
     vec3 crFB = texture(u_feedback, v_uv).rgb;
     col = fract(col + floor(crFB * 4.0) * 0.25);
   }
   // -- RING MOD: frame x feedback ring modulation --
   if(u_ringMod==1){
     vec3 rmFB = texture(u_feedback, v_uv).rgb;
     col = fract(col * rmFB * 6.0);
     col = fract(col * 3.0 + rmFB.gbr * 2.0);
   }
   // -- OVERFLOW: 8-bit integer overflow simulation --
   if(u_overflow==1){
     vec3 ovFB = texture(u_feedback, v_uv).rgb;
     col = fract(col * 255.0 + ovFB * 255.0);
     col = fract(col * 2.0 + 0.1);
   }
   // -- RECURSE: solarize applied 4x (tent map cascade) --
   if(u_recurse==1){
     col = 1.0 - abs(2.0*col - 1.0);
     col = 1.0 - abs(2.0*col - 1.0);
     col = 1.0 - abs(2.0*fract(col*1.1 + 0.05) - 1.0);
     col = 1.0 - abs(2.0*fract(col*0.9 + 0.02) - 1.0);
   }
   // -- GLITCH DNA: quantize -> cross-channel -> mod add -> tent -> sine fold --
   if(u_glitchDNA==1){
     vec3 gdFB = texture(u_feedback, v_uv).rgb;
     col = floor(col * 6.0) / 6.0;
     col = vec3(col.r*gdFB.g, col.g*gdFB.b, col.b*gdFB.r);
     col = mod(col * 5.0 + gdFB * 3.0, 1.0);
     col = 1.0 - abs(2.0*col - 1.0);
     col = sin(col * 3.14159 * 3.0) * 0.5 + 0.5;
   }
   // -- LOGISTIC: logistic map x=r*x*(1-x) in chaotic regime --
   if(u_logistic==1){
     vec3 lgFB = texture(u_feedback, v_uv).rgb;
     float lgR = 3.5 + dot(lgFB, vec3(0.299,0.587,0.114)) * 0.5;
     col = clamp(col, 0.001, 0.999);
     col = lgR * col * (1.0 - col);
     col = clamp(col, 0.001, 0.999);
     col = lgR * col * (1.0 - col);
     col = clamp(col, 0.001, 0.999);
     col = lgR * col * (1.0 - col);
     col = clamp(col, 0.001, 0.999);
     col = lgR * col * (1.0 - col);
   }
   // -- HASH MELT: deterministic hash on quantized color --
   if(u_hashMelt==1){
     vec3 hmQ = floor(col * 16.0);
     col.r = fract(sin(dot(hmQ.rg, vec2(12.9898, 78.233))) * 43758.5453);
     col.g = fract(sin(dot(hmQ.gb, vec2(45.164, 93.9898))) * 43758.5453);
     col.b = fract(sin(dot(hmQ.br, vec2(78.233, 12.9898))) * 43758.5453);
     vec3 hmFB = texture(u_feedback, v_uv).rgb;
     col = fract(col + floor(hmFB * 8.0) / 8.0);
   }
   // -- MIRROR FOLD: abs-value folding with feedback-driven axis --
   if(u_mirrorFold==1){
     vec3 mfFB = texture(u_feedback, v_uv).rgb;
     col = abs(abs(col - mfFB) - 0.5);
     col = abs(abs(col - mfFB.gbr) - 0.5);
     col = abs(abs(col - mfFB.brg) - 0.5);
   }
   // -- POWER CRUSH: feedback-driven power curve + fract wrap --
   if(u_powerCrush==1){
     vec3 pcFB = texture(u_feedback, v_uv).rgb;
     col = clamp(col, 0.001, 0.999);
     col = pow(col, 1.0 + pcFB * 4.0);
     col = fract(col * 3.0);
     col = 1.0 - abs(2.0*col - 1.0);
   }
   // -- STAIRCASE: feedback-driven variable quantization + cross-channel diff --
   if(u_staircase==1){
     vec3 scFB = texture(u_feedback, v_uv).rgb;
     vec3 scN = 2.0 + floor(scFB * 6.0);
     col = floor(col * scN) / scN;
     float scR = col.r;
     col.r = abs(col.r - col.g);
     col.g = abs(col.g - col.b);
     col.b = abs(col.b - scR);
     col = fract(col * 4.0);
   }
   // -- DIGIT: modular digit extraction per channel --
   if(u_digit==1){
     vec3 dgFB = texture(u_feedback, v_uv).rgb;
     col.r = fract(floor(col.r * 64.0) / 8.0);
     col.g = fract(floor(col.g * 32.0) / 4.0);
     col.b = fract(floor(col.b * 48.0) / 6.0);
     col = fract(col + dgFB * floor(dgFB * 4.0 + 1.0));
   }
   // -- DATAMOSH: per-channel drift from feedback difference --
   if(u_datamosh==1){
     vec3 dmFB = texture(u_feedback, v_uv).rgb;
     vec3 diff = col - dmFB;
     float dR = diff.r * 0.03;
     float dG = diff.g * 0.03;
     float dB = diff.b * 0.03;
     col.r = texture(u_feedback, v_uv + vec2(dR, dG)).r;
     col.g = texture(u_feedback, v_uv + vec2(-dG, dB)).g;
     col.b = texture(u_feedback, v_uv + vec2(dB, -dR)).b;
     col = mix(texture(u_tex, uv).rgb, col, 0.75);
   }
   // -- TOPO: topographic contour lines --
   if(u_topo==1){
     float topoL = dot(col, vec3(0.299,0.587,0.114));
     float lines = 10.0 + u_contour * 40.0;
     float contourVal = fract(topoL * lines + t * 0.5);
     float edge = smoothstep(0.0, 0.08, contourVal) * (1.0 - smoothstep(0.92, 1.0, contourVal));
     vec3 topoCol = col * edge;
     vec3 lineCol = vec3(0.1, 0.9, 0.6) * (1.0 - edge);
     col = mix(col, topoCol + lineCol, 0.6);
   }
   // -- CONTOUR knob: continuous posterize/contour lines --
   if(u_topo==0 && u_contour>0.01){
     float cL = dot(col, vec3(0.299,0.587,0.114));
     float cLines = 4.0 + u_contour * 30.0;
     float cEdge = abs(fract(cL * cLines) - 0.5) * 2.0;
     cEdge = smoothstep(0.3, 0.5, cEdge);
     col = mix(col * 0.3, col, cEdge);
   }
   // -- INTERFERENCE: double-slit wave pattern --
   if(u_interference==1){
     vec2 ifPx = 3.0/u_res;
     float ifL1 = dot(texture(u_feedback, v_uv + vec2(ifPx.x*3.0, 0.0)).rgb, vec3(0.299,0.587,0.114));
     float ifL2 = dot(texture(u_feedback, v_uv - vec2(ifPx.x*3.0, 0.0)).rgb, vec3(0.299,0.587,0.114));
     float d1 = length(uv - vec2(0.4, 0.5));
     float d2 = length(uv - vec2(0.6, 0.5));
     float wave1 = sin((d1 * 60.0 + ifL1 * 12.0) - t * 3.0);
     float wave2 = sin((d2 * 60.0 + ifL2 * 12.0) - t * 3.0);
     float pattern = (wave1 + wave2) * 0.5;
     vec3 ifCol = col + col * pattern * 0.5;
     col = mix(col, ifCol, 0.6);
   }

   // -- NEW: halftone --
   if(u_halftone>0.001){
     float htSz=3.0+u_halftone*12.0;
     vec2 htCell=floor(uv*u_res/htSz)*htSz/u_res;
     float htL=dot(texture(u_tex,htCell).rgb, vec3(0.299,0.587,0.114));
     float htDot=length(mod(uv*u_res,htSz)/htSz-0.5)*2.0;
     col=mix(col, vec3(step(htDot,htL)), u_halftone);
   }
   // -- NEW: emboss --
   if(u_emboss>0.001){
     vec2 ePx=1.0/u_res;
     col=mix(col, texture(u_tex,uv+ePx).rgb-texture(u_tex,uv-ePx).rgb+0.5, u_emboss);
   }
   // -- NEW: sharpen --
   if(u_sharpen>0.001){
     vec2 sPx=1.0/u_res; float sA=u_sharpen*2.0;
     vec3 sC=col*(1.0+4.0*sA);
     sC-=texture(u_tex,uv+vec2(sPx.x,0)).rgb*sA;
     sC-=texture(u_tex,uv-vec2(sPx.x,0)).rgb*sA;
     sC-=texture(u_tex,uv+vec2(0,sPx.y)).rgb*sA;
     sC-=texture(u_tex,uv-vec2(0,sPx.y)).rgb*sA;
     col=max(sC,0.0);
   }
   // -- NEW: blur --
   if(u_blur>0.001){
     vec2 bPx=u_blur*3.0/u_res;
     col=col*0.2
       +texture(u_tex,uv+vec2(bPx.x,0)).rgb*0.2
       +texture(u_tex,uv-vec2(bPx.x,0)).rgb*0.2
       +texture(u_tex,uv+vec2(0,bPx.y)).rgb*0.2
       +texture(u_tex,uv-vec2(0,bPx.y)).rgb*0.2;
   }
   // -- NEW: dither --
   if(u_dither>0.001){
     float dBayer=mod(dot(floor(mod(gl_FragCoord.xy,4.0)),vec2(4.0,1.0))*17.0,16.0)/16.0-0.5;
     float dLvl=max(2.0, 32.0*(1.0-u_dither));
     col=floor(col*dLvl+dBayer)/dLvl;
   }
   // -- NEW: bit crush --
   if(u_bitCrush==1) col=floor(col*4.0)/4.0;
   // -- NEW: color negative --
   if(u_colorNeg==1) col=clamp(vec3(1.0-col.b,1.0-col.r,1.0-col.g)*1.1, 0.0, 1.0);

   // -- HOLO: holographic rainbow interference --
   if(u_holo==1){
     float holoY = v_uv.y*u_res.y;
     float holoScan = sin(holoY*1.5 + t*8.0)*0.5+0.5;
     float holoRainbow = sin(holoY*0.08 + t*2.0 + v_uv.x*12.0);
     vec3 holoCol = 0.5 + 0.5*cos(6.28318*(holoRainbow + vec3(0.0, 0.33, 0.67)));
     float holoFlicker = 0.85 + 0.15*sin(t*30.0+v_uv.y*80.0);
     col = mix(col, col*holoCol*1.6, 0.45*holoScan) * holoFlicker;
     col.r = texture(u_tex, uv+vec2(sin(holoY*0.02+t*3.0)*0.003, 0.0)).r * mix(1.0, holoCol.r*1.4, 0.3);
   }
   // -- PLASMA: organic demo-scene plasma --
   if(u_plasma==1){
     float px1 = sin(v_uv.x*10.0 + t*2.0);
     float px2 = sin(v_uv.y*8.0 + t*1.5);
     float px3 = sin((v_uv.x+v_uv.y)*6.0 + t*3.0);
     float px4 = sin(length(v_uv-0.5)*14.0 - t*4.0);
     float pVal = (px1+px2+px3+px4)*0.25;
     vec3 plasma = 0.5+0.5*cos(6.28318*(pVal*1.5 + vec3(0.0, 0.25, 0.5) + t*0.1));
     float pLuma = dot(col, vec3(0.299,0.587,0.114));
     col = mix(col, plasma*(0.3+pLuma*1.4), 0.5);
   }
   // -- ECHO3D: anaglyph triple-delay feedback --
   if(u_echo3d==1){
     vec2 e3off = vec2(0.008, 0.003);
     vec3 e3L = texture(u_feedback, v_uv - e3off).rgb;
     vec3 e3R = texture(u_feedback, v_uv + e3off).rgb;
     vec3 e3C = texture(u_feedback, v_uv + vec2(0.0, 0.005)).rgb;
     col = vec3(
       max(col.r, e3L.r*0.8),
       max(col.g, e3C.g*0.7),
       max(col.b, e3R.b*0.8)
     );
     float e3depth = abs(e3L.r - e3R.r);
     col += vec3(0.0, e3depth*0.3, e3depth*0.5);
   }
   // -- TUNNEL: infinite recursive zoom --
   if(u_tunnel==1){
     vec2 tc = v_uv - 0.5;
     float tr = length(tc);
     float ta = atan(tc.y, tc.x);
     ta += sin(tr*8.0 - t*3.0)*0.3;
     float tunnelDepth = 0.2/(tr + 0.01);
     float tunnelZ = fract(tunnelDepth*0.15 + t*0.3);
     vec2 tunnelUV = vec2(ta/6.28318+0.5, tunnelZ);
     tunnelUV = clamp(tunnelUV, 0.0, 1.0);
     vec3 tunnelSrc = texture(u_feedback, tunnelUV).rgb;
     vec3 tunnelTex = texture(u_tex, tunnelUV).rgb;
     vec3 tunnelCol = mix(tunnelSrc, tunnelTex, 0.4);
     float rings = sin(tunnelDepth*2.0 - t*6.0)*0.5+0.5;
     tunnelCol *= (0.7 + 0.6*rings);
     float tunnelMask = smoothstep(0.0, 0.35, tr);
     col = mix(tunnelCol, col, tunnelMask*0.25);
   }

   if(u_mosh==1){
     vec3 prev=texture(u_feedback,v_uv).rgb;
     vec2 blockId=floor(v_uv*vec2(96.0,54.0));
     vec2 blockUV=blockId/vec2(96.0,54.0);
     float slowT=t*0.35;
     vec2 flow=(vec2(fbm(blockUV*4.0+vec2(slowT,-slowT*0.7)),
                     fbm(blockUV*6.0+vec2(-slowT*0.4,slowT)))-0.5)*0.18;
     vec3 smear=texture(u_feedback, clamp(v_uv+flow,0.0,1.0)).rgb;
     float diff=length(col-prev);
     col=mix(col, smear, 0.68+0.25*smoothstep(0.02,0.3,diff));
   }

   // -- NEW: echo --
   if(u_echo>0.001){
     vec3 echoCol=texture(u_feedback, v_uv+vec2(0.005,0.003)).rgb;
     col=mix(col, max(col,echoCol*0.9), u_echo*0.7);
   }
   // -- NEW: fractal feedback zoom --
   if(u_fractal>0.001){
     vec2 fUV=(v_uv-0.5)*(1.0-u_fractal*0.05)+0.5;
     col=mix(col, texture(u_feedback,fUV).rgb, u_fractal*0.4);
   }

   // -- REACTION: Gray-Scott inspired reaction-diffusion --
   if(u_reaction==1){
     vec2 rxPx = 1.0/u_res;
     vec3 rxCenter = texture(u_feedback, v_uv).rgb;
     vec3 rxLap = -4.0*rxCenter
       + texture(u_feedback, v_uv+vec2(rxPx.x,0)).rgb
       + texture(u_feedback, v_uv-vec2(rxPx.x,0)).rgb
       + texture(u_feedback, v_uv+vec2(0,rxPx.y)).rgb
       + texture(u_feedback, v_uv-vec2(0,rxPx.y)).rgb;
     col += rxLap * 0.2;
     col = clamp(col + col*col*(1.0-col)*0.5 - 0.06*col, 0.0, 1.0);
   }
   // -- CONWAY: Game of Life on luminance --
   if(u_conway==1){
     vec2 cwPx = 1.5/u_res;
     float cwCount = 0.0;
     float cwSelf = dot(texture(u_feedback, v_uv).rgb, vec3(0.299,0.587,0.114));
     for(int dy=-1; dy<=1; dy++){
       for(int dx=-1; dx<=1; dx++){
         if(dx==0 && dy==0) continue;
         vec3 nb = texture(u_feedback, v_uv + vec2(float(dx),float(dy))*cwPx).rgb;
         cwCount += step(0.5, dot(nb, vec3(0.299,0.587,0.114)));
       }
     }
     float alive = step(0.5, cwSelf);
     float born = (1.0-alive)*step(2.5,cwCount)*step(cwCount,3.5);
     float survive = alive*step(1.5,cwCount)*step(cwCount,3.5);
     float cwResult = clamp(born+survive, 0.0, 1.0);
     col = mix(col, col * cwResult + (1.0-cwResult)*col.gbr*0.5, 0.6);
   }
   // -- SMEAR: directional pixel smear along luminance gradient --
   if(u_smear==1){
     vec2 smPx = 2.0/u_res;
     vec3 smC = texture(u_feedback, v_uv).rgb;
     float smL = dot(smC, vec3(0.299,0.587,0.114));
     float smLR = dot(texture(u_feedback, v_uv+vec2(smPx.x,0)).rgb, vec3(0.299,0.587,0.114));
     float smLU = dot(texture(u_feedback, v_uv+vec2(0,smPx.y)).rgb, vec3(0.299,0.587,0.114));
     vec2 smGrad = vec2(smLR - smL, smLU - smL);
     float smLen = length(smGrad);
     if(smLen > 0.001){
       smGrad /= smLen;
       vec3 smTrail = texture(u_feedback, v_uv - smGrad*smPx*4.0).rgb;
       col = mix(col, smTrail, 0.45);
     }
   }
   // -- AUTOMATA: 1D cellular automaton (Rule 30/110 hybrid) --
   if(u_automata==1){
     vec2 caPx = 1.0/u_res;
     float caL = dot(texture(u_feedback, v_uv - vec2(caPx.x,0)).rgb, vec3(0.299,0.587,0.114));
     float caC = dot(texture(u_feedback, v_uv).rgb, vec3(0.299,0.587,0.114));
     float caR = dot(texture(u_feedback, v_uv + vec2(caPx.x,0)).rgb, vec3(0.299,0.587,0.114));
     int caState = (int(step(0.5,caL))<<2) | (int(step(0.5,caC))<<1) | int(step(0.5,caR));
     int rule30 = 30;
     int rule110 = 110;
     float r30 = float((rule30 >> caState) & 1);
     float r110 = float((rule110 >> caState) & 1);
     float caResult = mix(r30, r110, sin(t*0.5)*0.5+0.5);
     vec3 caCol = mix(col, col.brg * caResult + col.gbr * (1.0-caResult), 0.55);
     col = mix(col, caCol, 0.6);
   }
   // -- DELTA: temporal difference amplifier --
   if(u_delta==1){
     vec3 dlFB = texture(u_feedback, v_uv).rgb;
     vec3 dlDiff = abs(col - dlFB);
     dlDiff = dlDiff * dlDiff * 8.0;
     vec3 dlHeat = vec3(
       dlDiff.r + dlDiff.g * 0.3,
       dlDiff.g + dlDiff.b * 0.3,
       dlDiff.b + dlDiff.r * 0.3
     );
     col = mix(col, clamp(col + dlHeat, 0.0, 1.0), 0.7);
   }

   vec3 fb=texture(u_feedback,v_uv).rgb;
   float fbAmt=clamp(u_feedbackAmt+MF,0.0,0.98);
   col=mix(col,fb,fbAmt);
   col*=u_decay;

   if(u_invert==1) col=1.0-col;
   outCol=vec4(clamp(col,0.0,1.0),1.0);
 }`;

  const blitFS = `#version 300 es
 precision highp float;
 in vec2 v_uv;
 uniform sampler2D u_src;
 out vec4 outCol;
 void main(){ outCol = texture(u_src,v_uv); }`;

  const postFS = `#version 300 es
 precision highp float;
 in vec2 v_uv;
 uniform sampler2D u_src;
 uniform sampler2D u_audioWave;
 uniform float u_time;
 uniform float u_chromatic;
 uniform float u_vignette;
 uniform float u_filmGrain;
 uniform float u_audioLevel;
 uniform int u_scope;
 uniform int u_pulse;
 uniform int u_rhythm;
 out vec4 outCol;
 float rand(vec2 c){ return fract(sin(dot(c,vec2(12.9898,78.233)))*43758.5453); }
 void main(){
   vec2 uv = v_uv;
   if(u_rhythm==1){
     float bounce = u_audioLevel * 0.03 * sin(u_time * 8.0);
     uv.x += bounce;
     uv.y += u_audioLevel * 0.02 * cos(u_time * 6.0);
     uv = clamp(uv, 0.0, 1.0);
   }
   vec2 cen = vec2(0.5);
   vec2 dir = uv - cen;
   float r = length(dir);
   dir = r > 0.0001 ? dir / r : vec2(0.0);
   float off = u_chromatic * r * 0.025;
   vec4 col = texture(u_src, uv);
   if(u_chromatic > 0.001){
     col.r = texture(u_src, uv + dir*off).r;
     col.b = texture(u_src, uv - dir*off).b;
   }
   col.rgb *= 1.0 - u_vignette * r * r * 4.0;
   col.rgb += (rand(uv + u_time) - 0.5) * u_filmGrain;
   if(u_pulse==1){
     float p = 1.0 + u_audioLevel * 0.5 + 0.15 * sin(u_time * 12.0) * u_audioLevel;
     col.rgb *= p;
   }
   if(u_scope==1){
     float wave = texture(u_audioWave, vec2(uv.x, 0.5)).r;
     float yScope = 0.5 + (wave - 0.5) * 0.5;
     float dist = abs(uv.y - yScope);
     float line = smoothstep(0.018, 0.004, dist);
     vec3 scopeCol = vec3(0.2, 0.9, 1.0);
     col.rgb = mix(col.rgb, scopeCol, line * 0.95);
     float glow = smoothstep(0.08, 0.0, dist) * 0.4;
     col.rgb += scopeCol * glow;
   }
   outCol = col;
 }`;

  function sh(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){
      console.error(gl.getShaderInfoLog(s));
      return null;
    }
    return s;
  }
  function prog(vsSrc,fsSrc){
    const p=gl.createProgram();
    const vsS=sh(gl.VERTEX_SHADER,vsSrc);
    const fsS=sh(gl.FRAGMENT_SHADER,fsSrc);
    if(!vsS || !fsS){ console.error('[GlitchLab] Shader compile failed'); return null; }
    gl.attachShader(p,vsS);
    gl.attachShader(p,fsS);
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)){
      console.error('[GlitchLab] Program link failed:', gl.getProgramInfoLog(p));
      return null;
    }
    return p;
  }
  const mainProg=prog(vs,fs);
  if(!mainProg){ alert('Shader compilation failed — check console for errors.'); return; }
  const blitProg=prog(vs,blitFS);
  const postProg=prog(vs,postFS);

  const quad=new Float32Array([-1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1]);
  const buf=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,buf);
  gl.bufferData(gl.ARRAY_BUFFER,quad,gl.STATIC_DRAW);
  const posMain=gl.getAttribLocation(mainProg,'a_pos');
  const posBlit=gl.getAttribLocation(blitProg,'a_pos');
  const posPost=gl.getAttribLocation(postProg,'a_pos');
  const U=(p,n)=>gl.getUniformLocation(p,n);

  const RESOLUTIONS = { '720p': [1280,720], '1080p': [1920,1080], '4K': [3840,2160] };

  // ═══════════════════════════════════════════
  // KNOB REGISTRY
  // ═══════════════════════════════════════════
  const KNOB_REGISTRY = [
    // -- Core --
    {id:'tempo',label:'TEMPO',cat:'Core',def:0.35,transform:v=>v,stateKey:'tempo',desc:'Animation speed'},
    {id:'chaos',label:'CHAOS',cat:'Core',def:0.35,transform:v=>v,stateKey:'chaos',desc:'Random disruption'},
    {id:'glitch',label:'GLITCH',cat:'Core',def:0,transform:v=>v,stateKey:'glitch',desc:'Glitch bands'},
    {id:'pixel',label:'PIXELATE',cat:'Core',def:0,transform:v=>1+v*80,stateKey:'pixel',desc:'Pixel size'},
    {id:'rgb',label:'RGB SHIFT',cat:'Core',def:0,transform:v=>v,stateKey:'rgb',desc:'Channel offset'},
    {id:'feedback',label:'FEEDBACK',cat:'Core',def:0,transform:v=>v*0.95,stateKey:'feedbackAmt',desc:'Trails intensity'},
    {id:'noise',label:'NOISE',cat:'Core',def:0,transform:v=>v,stateKey:'noise',desc:'Static noise'},
    {id:'speed',label:'SPEED',cat:'Core',def:0.33,transform:v=>v,stateKey:'speed',desc:'Time multiplier'},
    // -- Color --
    {id:'hue',label:'HUE',cat:'Color',def:0,transform:v=>v,stateKey:'hue',desc:'Hue rotation'},
    {id:'palette',label:'PALETTE',cat:'Color',def:0,transform:v=>v,stateKey:'palette',desc:'Cosmic palette'},
    {id:'sat',label:'SAT',cat:'Color',def:0.5,transform:v=>v,stateKey:'sat',desc:'Saturation'},
    {id:'bright',label:'BRIGHT',cat:'Color',def:0.52,transform:v=>v,stateKey:'bright',desc:'Brightness'},
    {id:'contrast',label:'CONTRAST',cat:'Color',def:0.5,transform:v=>v,stateKey:'contrast',desc:'Contrast'},
    {id:'temperature',label:'TEMP',cat:'Color',def:0.5,transform:v=>(v-0.5)*2,stateKey:'temperature',desc:'Warm / cool'},
    {id:'vibrance',label:'VIBRANCE',cat:'Color',def:0,transform:v=>v,stateKey:'vibrance',desc:'Color pop'},
    {id:'gamma',label:'GAMMA',cat:'Color',def:0.5,transform:v=>v,stateKey:'gamma',desc:'Gamma curve'},
    {id:'threshold',label:'THRESHOLD',cat:'Color',def:0,transform:v=>v,stateKey:'threshold',desc:'B/W cutoff'},
    {id:'tint',label:'TINT',cat:'Color',def:0,transform:v=>v,stateKey:'tint',desc:'Color tint'},
    {id:'duotone',label:'DUOTONE',cat:'Color',def:0,transform:v=>v,stateKey:'duotone',desc:'Two-tone map'},
    // -- Geometric --
    {id:'swirl',label:'SWIRL',cat:'Geo',def:0,transform:v=>v*2,stateKey:'swirl',desc:'Spiral warp'},
    {id:'ripple',label:'RIPPLE',cat:'Geo',def:0,transform:v=>v*1.5,stateKey:'ripple',desc:'Wave ripple'},
    {id:'warp',label:'WARP',cat:'Geo',def:0,transform:v=>v*1.2,stateKey:'warp',desc:'Radial warp'},
    {id:'zoom',label:'ZOOM',cat:'Geo',def:0,transform:v=>v,stateKey:'zoom',desc:'Center zoom'},
    {id:'rotate',label:'ROTATE',cat:'Geo',def:0,transform:v=>v,stateKey:'frameRotate',desc:'Frame rotation'},
    {id:'tile',label:'TILE',cat:'Geo',def:0,transform:v=>v,stateKey:'tile',desc:'Grid repeat'},
    {id:'barrel',label:'BARREL',cat:'Geo',def:0,transform:v=>v,stateKey:'barrel',desc:'Lens distortion'},
    {id:'turbulence',label:'TURB',cat:'Geo',def:0,transform:v=>v,stateKey:'turbulence',desc:'Noise warp'},
    {id:'drift',label:'DRIFT',cat:'Geo',def:0,transform:v=>v,stateKey:'drift',desc:'Slow panning'},
    {id:'fractal',label:'FRACTAL',cat:'Geo',def:0,transform:v=>v,stateKey:'fractal',desc:'Fractal zoom'},
    // -- Creative --
    {id:'bloom',label:'BLOOM',cat:'Creative',def:0.1,transform:v=>v,stateKey:'bloom',desc:'Glow bloom'},
    {id:'poster',label:'POSTER',cat:'Creative',def:0.33,transform:v=>2+Math.floor(v*14),stateKey:'poster',desc:'Color steps'},
    {id:'halftone',label:'HALFTONE',cat:'Creative',def:0,transform:v=>v,stateKey:'halftone',desc:'Dot screen'},
    {id:'emboss',label:'EMBOSS',cat:'Creative',def:0,transform:v=>v,stateKey:'emboss',desc:'Relief effect'},
    {id:'sharpen',label:'SHARPEN',cat:'Creative',def:0,transform:v=>v,stateKey:'sharpen',desc:'Edge sharpen'},
    {id:'blur',label:'BLUR',cat:'Creative',def:0,transform:v=>v,stateKey:'blur',desc:'Soft blur'},
    {id:'dither',label:'DITHER',cat:'Creative',def:0,transform:v=>v,stateKey:'dither',desc:'Ordered dither'},
    {id:'vhsWobble',label:'VHS',cat:'Creative',def:0,transform:v=>v,stateKey:'vhsWobble',desc:'VHS wobble'},
    {id:'echo',label:'ECHO',cat:'Creative',def:0,transform:v=>v,stateKey:'echo',desc:'Ghost trails'},
    {id:'morph',label:'MORPH',cat:'Geo',def:0,transform:v=>v,stateKey:'morph',desc:'Organic displacement'},
    {id:'waveSlice',label:'WAVE',cat:'Geo',def:0,transform:v=>v,stateKey:'waveSlice',desc:'Sine wave warp'},
    {id:'crystal',label:'CRYSTAL',cat:'Geo',def:0,transform:v=>v,stateKey:'crystal',desc:'Voronoi facets'},
    {id:'foldAmt',label:'FOLD AMT',cat:'Chaos',def:0,transform:v=>v,stateKey:'foldAmt',desc:'Wave folding intensity'},
    {id:'contour',label:'CONTOUR',cat:'Chaos',def:0,transform:v=>v,stateKey:'contour',desc:'Topo contour spacing'},
  ];

  // ═══════════════════════════════════════════
  // EFFECT (TOGGLE) REGISTRY
  // ═══════════════════════════════════════════
  const EFFECT_REGISTRY = [
    {id:'displace',label:'DISPLACE',cat:'Glitch',stateKey:'displace'},
    {id:'scan',label:'SCANLINES',cat:'Glitch',stateKey:'scan'},
    {id:'invert',label:'INVERT',cat:'Color',stateKey:'invert'},
    {id:'strobe',label:'STROBE',cat:'Temporal',stateKey:'strobe'},
    {id:'mirror',label:'MIRROR',cat:'Geo',stateKey:'mirror'},
    {id:'edge',label:'EDGE',cat:'Creative',stateKey:'edge'},
    {id:'solar',label:'SOLARIZE',cat:'Color',stateKey:'solar'},
    {id:'slit',label:'SLIT-SCAN',cat:'Temporal',stateKey:'slit'},
    {id:'kaleido',label:'KALEIDO',cat:'Geo',stateKey:'kaleido'},
    {id:'mosh',label:'MELT',cat:'Glitch',stateKey:'mosh'},
    {id:'vector',label:'VORTEX',cat:'Geo',stateKey:'vector'},
    {id:'scope',label:'SCOPE',cat:'Audio',stateKey:'scope'},
    {id:'pulse',label:'PULSE',cat:'Audio',stateKey:'pulse'},
    {id:'rhythm',label:'RHYTHM',cat:'Audio',stateKey:'rhythm'},
    {id:'thermal',label:'THERMAL',cat:'Color',stateKey:'thermal'},
    {id:'nightVis',label:'NIGHT VIS',cat:'Color',stateKey:'nightVis'},
    {id:'prism',label:'PRISM',cat:'Color',stateKey:'prism'},
    {id:'freeze',label:'FREEZE',cat:'Temporal',stateKey:'freeze'},
    {id:'stutter',label:'STUTTER',cat:'Temporal',stateKey:'stutter'},
    {id:'pixelSort',label:'PIX SORT',cat:'Glitch',stateKey:'pixelSort'},
    {id:'glitchBlocks',label:'BLOCKS',cat:'Glitch',stateKey:'glitchBlocks'},
    {id:'staticTV',label:'STATIC',cat:'Glitch',stateKey:'staticTV'},
    {id:'rainbowWash',label:'RAINBOW',cat:'Color',stateKey:'rainbowWash'},
    {id:'zoomBlur',label:'ZOOM BLUR',cat:'Blur',stateKey:'zoomBlur'},
    {id:'spinBlur',label:'SPIN BLUR',cat:'Blur',stateKey:'spinBlur'},
    {id:'crossProcess',label:'CROSS',cat:'Color',stateKey:'crossProcess'},
    {id:'colorNeg',label:'NEGATIVE',cat:'Color',stateKey:'colorNeg'},
    {id:'tile4x',label:'TILE 4X',cat:'Geo',stateKey:'tile4x'},
    {id:'filmBurn',label:'FILM BURN',cat:'Creative',stateKey:'filmBurn'},
    {id:'bitCrush',label:'BIT CRUSH',cat:'Creative',stateKey:'bitCrush'},
    {id:'liquid',label:'LIQUID',cat:'Movement',stateKey:'liquid'},
    {id:'tunnel',label:'TUNNEL',cat:'Movement',stateKey:'tunnel'},
    {id:'shatter',label:'SHATTER',cat:'Movement',stateKey:'shatter'},
    {id:'holo',label:'HOLO',cat:'Color',stateKey:'holo'},
    {id:'plasma',label:'PLASMA',cat:'Color',stateKey:'plasma'},
    {id:'echo3d',label:'ECHO 3D',cat:'Movement',stateKey:'echo3d'},
    {id:'sineSlice',label:'SINE CUT',cat:'Movement',stateKey:'sineSlice'},
    {id:'refract',label:'REFRACT',cat:'Movement',stateKey:'refract'},
    {id:'fold',label:'FOLD',cat:'Chaos',stateKey:'fold'},
    {id:'reaction',label:'REACTION',cat:'Chaos',stateKey:'reaction'},
    {id:'conway',label:'CONWAY',cat:'Chaos',stateKey:'conway'},
    {id:'fractalMap',label:'FRACTAL MAP',cat:'Chaos',stateKey:'fractalMap'},
    {id:'xorMelt',label:'XOR MELT',cat:'Chaos',stateKey:'xorMelt'},
    {id:'phaseWarp',label:'PHASE WARP',cat:'Chaos',stateKey:'phaseWarp'},
    {id:'topo',label:'TOPO',cat:'Chaos',stateKey:'topo'},
    {id:'smear',label:'SMEAR',cat:'Chaos',stateKey:'smear'},
    {id:'datamosh',label:'DATAMOSH',cat:'Chaos',stateKey:'datamosh'},
    {id:'automata',label:'AUTOMATA',cat:'Chaos',stateKey:'automata'},
    {id:'strange',label:'STRANGE',cat:'Chaos',stateKey:'strange'},
    {id:'tessellate',label:'TESSELLATE',cat:'Chaos',stateKey:'tessellate'},
    {id:'delta',label:'DELTA',cat:'Chaos',stateKey:'delta'},
    {id:'interference',label:'INTERFERE',cat:'Chaos',stateKey:'interference'},
    {id:'shred',label:'SHRED',cat:'Chaos',stateKey:'shred'},
    {id:'corrupt',label:'CORRUPT',cat:'Chaos',stateKey:'corrupt'},
    {id:'ringMod',label:'RING MOD',cat:'Chaos',stateKey:'ringMod'},
    {id:'overflow',label:'OVERFLOW',cat:'Chaos',stateKey:'overflow'},
    {id:'recurse',label:'RECURSE',cat:'Chaos',stateKey:'recurse'},
    {id:'glitchDNA',label:'GLITCH DNA',cat:'Chaos',stateKey:'glitchDNA'},
    {id:'logistic',label:'LOGISTIC',cat:'Chaos',stateKey:'logistic'},
    {id:'hashMelt',label:'HASH MELT',cat:'Chaos',stateKey:'hashMelt'},
    {id:'mirrorFold',label:'MIRROR FOLD',cat:'Chaos',stateKey:'mirrorFold'},
    {id:'powerCrush',label:'PWR CRUSH',cat:'Chaos',stateKey:'powerCrush'},
    {id:'staircase',label:'STAIRCASE',cat:'Chaos',stateKey:'staircase'},
    {id:'digit',label:'DIGIT',cat:'Chaos',stateKey:'digit'},
  ];

  const LEFT_KEYS = ['KeyQ','KeyW','KeyE','KeyR','KeyT','KeyY','KeyU','KeyI'];
  const LEFT_LABELS = ['Q','W','E','R','T','Y','U','I'];
  const RIGHT_KEYS = ['KeyA','KeyS','KeyD','KeyF','KeyG','KeyH','KeyJ','KeyK'];
  const RIGHT_LABELS = ['A','S','D','F','G','H','J','K'];
  const EFF_CODES_R1 = ['Digit1','Digit2','Digit3','Digit4','Digit5','Digit6','Digit7','Digit8','Digit9','Digit0','Minus','Equal'];
  const EFF_LABELS_R1 = ['1','2','3','4','5','6','7','8','9','0','-','='];
  const EFF_LABELS_R2 = ['⇧1','⇧2','⇧3','⇧4','⇧5','⇧6','⇧7','⇧8','⇧9','⇧0','⇧-','⇧='];

  const ACTIVE_STORAGE = 'glitchlab-active-config';

  function defaultActiveConfig(){
    return {
      left:['tempo','chaos','glitch','pixel','rgb','feedback','hue','palette'],
      right:['sat','bright','contrast','bloom','foldAmt','contour','warp','poster'],
      effectsR1:['fold','solar','slit','xorMelt','phaseWarp','fractalMap','shred','corrupt','ringMod','overflow','recurse','glitchDNA'],
      effectsR2:['reaction','conway','logistic','hashMelt','mirrorFold','powerCrush','staircase','digit','smear','topo','mosh','freeze'],
    };
  }

  const CONFIG_VERSION = 5;
  let activeConfig;
  try {
    const stored = localStorage.getItem(ACTIVE_STORAGE);
    activeConfig = stored ? JSON.parse(stored) : defaultActiveConfig();
    if(!activeConfig.left || activeConfig._v !== CONFIG_VERSION) activeConfig = defaultActiveConfig();
  } catch(e){ activeConfig = defaultActiveConfig(); }
  activeConfig._v = CONFIG_VERSION;

  function saveActiveConfig(){ localStorage.setItem(ACTIVE_STORAGE, JSON.stringify(activeConfig)); }

  // ═══════════════════════════════════════════
  // STATE + DEFAULTS
  // ═══════════════════════════════════════════
  const defaults={
    tempo:0.35, chaos:0.35, speed:0.33,
    glitch:0.0, pixel:1.0, rgb:0.0, noise:0.0,
    feedbackAmt:0.0, decay:0.98,
    hue:0.0, palette:0.0,
    sat:0.5, bright:0.52, contrast:0.5, bloom:0.1,
    swirl:0.0, ripple:0.0, warp:0.0,
    zoom:0.0, frameRotate:0.0, tile:0.0, barrel:0.0,
    turbulence:0.0, drift:0.0, fractal:0.0,
    temperature:0.0, vibrance:0.0, gamma:0.5, threshold:0.0,
    tint:0.0, duotone:0.0, echo:0.0,
    halftone:0.0, emboss:0.0, sharpen:0.0, blur:0.0, dither:0.0, vhsWobble:0.0,
    morph:0.0, waveSlice:0.0, crystal:0.0,
    poster:6.0,
    displace:0, scan:0, invert:0, strobe:0, mirror:0, edge:0,
    solar:0, slit:0, kaleido:0, mosh:0, vector:0,
    scope:0, pulse:0, rhythm:0,
    thermal:0, nightVis:0, prism:0, freeze:0, stutter:0,
    pixelSort:0, glitchBlocks:0, staticTV:0, rainbowWash:0,
    zoomBlur:0, spinBlur:0, crossProcess:0, colorNeg:0,
    tile4x:0, filmBurn:0, bitCrush:0,
    liquid:0, tunnel:0, shatter:0, holo:0, plasma:0,
    echo3d:0, sineSlice:0, refract:0,
    fold:0, reaction:0, conway:0, fractalMap:0,
    xorMelt:0, phaseWarp:0, topo:0, smear:0,
    foldAmt:0, contour:0,
    datamosh:0, automata:0, strange:0, tessellate:0, delta:0, interference:0,
    shred:0, corrupt:0, ringMod:0, overflow:0, recurse:0, glitchDNA:0,
    logistic:0, hashMelt:0, mirrorFold:0, powerCrush:0, staircase:0, digit:0,
    g:{rate:0.0,depth:0.0,wave:3,seed:Math.random()*100},
    p:{rate:0.0,depth:0.0,wave:1,seed:Math.random()*100},
    r:{rate:0.0,depth:0.0,wave:0,seed:Math.random()*100},
    f:{rate:0.0,depth:0.0,wave:2,seed:Math.random()*100},
    h:{rate:0.0,depth:0.0,wave:0,seed:Math.random()*100},
    pal:{rate:0.0,depth:0.0,wave:1,seed:Math.random()*100},
    mod:{g:0, p:0, r:0, f:0, h:0, pal:0},
    internalRes:'1080p',
    chromatic:0.0, vignette:0.0, filmGrain:0.0,
  };
  let state=JSON.parse(JSON.stringify(defaults));
  let freqData = null;
  if(analyser) freqData = new Uint8Array(analyser.frequencyBinCount);

  // Dynamic uniform cache from registries
  const uni={ res:U(mainProg,'u_res'), texRes:U(mainProg,'u_texRes'), time:U(mainProg,'u_time'), decay:U(mainProg,'u_decay') };
  const knobUni = {};
  KNOB_REGISTRY.forEach(k => { knobUni[k.stateKey] = U(mainProg, 'u_'+k.stateKey); });
  const effUni = {};
  EFFECT_REGISTRY.forEach(e => { effUni[e.stateKey] = U(mainProg, 'u_'+e.stateKey); });
  const lfoUni = {};
  ['g','p','r','f','h','pal'].forEach(k => {
    lfoUni[k+'_rate']=U(mainProg,'u_'+k+'_rate'); lfoUni[k+'_depth']=U(mainProg,'u_'+k+'_depth');
    lfoUni[k+'_wave']=U(mainProg,'u_'+k+'_wave'); lfoUni[k+'_seed']=U(mainProg,'u_'+k+'_seed');
  });
  const blitU={ src:U(blitProg,'u_src') };
  const postUni={
    src:U(postProg,'u_src'),
    audioWave:U(postProg,'u_audioWave'),
    time:U(postProg,'u_time'),
    chromatic:U(postProg,'u_chromatic'),
    vignette:U(postProg,'u_vignette'),
    filmGrain:U(postProg,'u_filmGrain'),
    audioLevel:U(postProg,'u_audioLevel'),
    scope:U(postProg,'u_scope'),
    pulse:U(postProg,'u_pulse'),
    rhythm:U(postProg,'u_rhythm')
  };

  // textures & FBOs
  const videoTex=gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,videoTex);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,2,2,0,gl.RGBA,gl.UNSIGNED_BYTE,
    new Uint8Array([0,0,0,255,0,0,0,255,0,0,0,255,0,0,0,255]));

  const waveformTex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, waveformTex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.R8, 256, 1, 0, gl.RED, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

  function createFBO(w,h){
    const tex=gl.createTexture();
    gl.bindTexture(gl.TEXTURE_2D,tex);
    gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,w,h,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
    gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
    const fb=gl.createFramebuffer();
    gl.bindFramebuffer(gl.FRAMEBUFFER,fb);
    gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,tex,0);
    return {tex,fb};
  }
  let fboA=createFBO(canvas.width,canvas.height);
  let fboB=createFBO(canvas.width,canvas.height);
  let fboPost=createFBO(canvas.width,canvas.height);
  const resizeFBOS=()=>{
    [fboA,fboB,fboPost].forEach(o=>{
      gl.bindTexture(gl.TEXTURE_2D,o.tex);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,canvas.width,canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
    });
  };

  // sizing: internal resolution (720p / 1080p / 4K), display via CSS
  function fitCanvas(){
    const [iw, ih] = RESOLUTIONS[state.internalRes] || RESOLUTIONS['1080p'];
    canvas.width = iw;
    canvas.height = ih;
    canvas.style.width = '100%';
    canvas.style.height = '100%';
    gl.viewport(0, 0, iw, ih);
    resizeFBOS();
  }
  window.addEventListener('resize', fitCanvas);
  fitCanvas();

  // render loop
  let ping=true;
  let start=performance.now();
  function render(){
    const t=(performance.now()-start)/1000.0;

    gl.bindTexture(gl.TEXTURE_2D,videoTex);
    const src = getVideoSource();
    if(hasVideoFrame()){
      gl.pixelStorei(gl.UNPACK_ALIGNMENT,1);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,src);
    }

    const writeFBO= ping? fboA.fb : fboB.fb;
    const readTex= ping? fboB.tex : fboA.tex;

    gl.bindFramebuffer(gl.FRAMEBUFFER,writeFBO);
    gl.useProgram(mainProg);
    gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    gl.enableVertexAttribArray(posMain);
    gl.vertexAttribPointer(posMain,2,gl.FLOAT,false,0,0);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,videoTex);
    gl.uniform1i(U(mainProg,'u_tex'),0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D,readTex);
    gl.uniform1i(U(mainProg,'u_feedback'),1);

    gl.uniform2f(uni.res,canvas.width,canvas.height);
    const vw = src.videoWidth || 1280, vh = src.videoHeight || 720;
    gl.uniform2f(uni.texRes, vw, vh);
    gl.uniform1f(uni.time,t);
    gl.uniform1f(uni.decay,state.decay);

    // upload all knob uniforms dynamically
    for(const sk in knobUni){ if(knobUni[sk]!==null) gl.uniform1f(knobUni[sk], state[sk]??0); }
    // upload all effect uniforms dynamically
    for(const sk in effUni){ if(effUni[sk]!==null) gl.uniform1i(effUni[sk], state[sk]??0); }
    // LFO uniforms
    ['g','p','r','f','h','pal'].forEach(k=>{
      gl.uniform1f(lfoUni[k+'_rate'],state[k].rate); gl.uniform1f(lfoUni[k+'_depth'],state[k].depth);
      gl.uniform1i(lfoUni[k+'_wave'],state[k].wave); gl.uniform1f(lfoUni[k+'_seed'],state[k].seed);
    });

    gl.drawArrays(gl.TRIANGLES,0,6);

    const screenTex= ping? fboA.tex : fboB.tex;
    gl.bindFramebuffer(gl.FRAMEBUFFER,fboPost.fb);
    gl.useProgram(blitProg);
    gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    gl.enableVertexAttribArray(posBlit);
    gl.vertexAttribPointer(posBlit,2,gl.FLOAT,false,0,0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,screenTex);
    gl.uniform1i(blitU.src,0);
    gl.drawArrays(gl.TRIANGLES,0,6);

    if(analyser && waveformData){
      analyser.getByteTimeDomainData(waveformData);
      gl.bindTexture(gl.TEXTURE_2D, waveformTex);
      gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, 256, 1, gl.RED, gl.UNSIGNED_BYTE, waveformData);
    }
    if(analyser && freqData){
      analyser.getByteFrequencyData(freqData);
      let sum = 0;
      for(let i = 0; i < Math.min(32, freqData.length); i++) sum += freqData[i];
      audioLevel = Math.min(1, sum / (32 * 200));
    }

    gl.bindFramebuffer(gl.FRAMEBUFFER,null);
    gl.useProgram(postProg);
    gl.bindBuffer(gl.ARRAY_BUFFER,buf);
    gl.enableVertexAttribArray(posPost);
    gl.vertexAttribPointer(posPost,2,gl.FLOAT,false,0,0);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D,fboPost.tex);
    gl.uniform1i(postUni.src,0);
    gl.activeTexture(gl.TEXTURE1);
    gl.bindTexture(gl.TEXTURE_2D, waveformTex);
    gl.uniform1i(postUni.audioWave,1);
    gl.uniform1f(postUni.time,t);
    gl.uniform1f(postUni.chromatic,state.chromatic);
    gl.uniform1f(postUni.vignette,state.vignette);
    gl.uniform1f(postUni.filmGrain,state.filmGrain);
    gl.uniform1f(postUni.audioLevel,audioLevel);
    gl.uniform1i(postUni.scope,state.scope);
    gl.uniform1i(postUni.pulse,state.pulse);
    gl.uniform1i(postUni.rhythm,state.rhythm);
    gl.drawArrays(gl.TRIANGLES,0,6);

    ping=!ping;
    requestAnimationFrame(render);
  }
  requestAnimationFrame(render);

  // --- Source: Camera / Upload ---
  const sourceCameraBtn = document.getElementById('sourceCamera');
  const sourceUploadBtn = document.getElementById('sourceUpload');
  const fileInput = document.getElementById('fileInput');
  const sourceFilenameEl = document.getElementById('sourceFilename');
  const sourceClearBtn = document.getElementById('sourceClear');
  const recordBtn = document.getElementById('recordBtn');
  const downloadBtn = document.getElementById('downloadBtn');
  const recordingIndicator = document.getElementById('recordingIndicator');

  function updateSourceUI(){
    if(useUpload){
      sourceCameraBtn.classList.remove('on');
      sourceUploadBtn.classList.add('on');
      sourceClearBtn.style.display = '';
    } else {
      sourceCameraBtn.classList.add('on');
      sourceUploadBtn.classList.remove('on');
      sourceFilenameEl.textContent = '';
      sourceClearBtn.style.display = 'none';
    }
  }
  if(sourceCameraBtn){
    sourceCameraBtn.addEventListener('click', ()=>{
      useUpload = false;
      if(uploadVideo.parentNode) uploadVideo.parentNode.removeChild(uploadVideo);
      updateSourceUI();
    });
  }
  if(sourceUploadBtn){
    sourceUploadBtn.addEventListener('click', ()=> fileInput && fileInput.click());
  }
  if(fileInput){
    fileInput.addEventListener('change', (e)=>{
      const file = e.target.files && e.target.files[0];
      if(!file) return;
      if(uploadObjectURL) URL.revokeObjectURL(uploadObjectURL);
      uploadObjectURL = URL.createObjectURL(file);
      uploadVideo.src = uploadObjectURL;
      uploadVideo.muted = audioMode !== 'video';
      if(audioMode === 'video'){ if(!uploadVideo.parentNode) document.body.appendChild(uploadVideo); }
      uploadVideo.play().catch(()=>{});
      useUpload = true;
      sourceFilenameEl.textContent = file.name || 'Video';
      updateSourceUI();
      e.target.value = '';
    });
  }
  if(sourceClearBtn){
    sourceClearBtn.addEventListener('click', ()=>{
      if(uploadObjectURL){ URL.revokeObjectURL(uploadObjectURL); uploadObjectURL = null; }
      uploadVideo.src = ''; uploadVideo.pause();
      if(uploadVideo.parentNode) uploadVideo.parentNode.removeChild(uploadVideo);
      useUpload = false;
      updateSourceUI();
    });
  }
  updateSourceUI();

  function updateUploadAudio(){
    if(!useUpload || !uploadVideo.src) return;
    uploadVideo.muted = audioMode !== 'video';
    if(audioMode === 'video'){ if(!uploadVideo.parentNode) document.body.appendChild(uploadVideo); }
    else { if(uploadVideo.parentNode) uploadVideo.parentNode.removeChild(uploadVideo); }
  }

  function setAudioMode(mode){
    audioMode = mode;
    document.querySelectorAll('#audioNone,#audioVideo').forEach(btn=>{
      if(btn) btn.classList.toggle('on', btn.id === 'audioNone' && mode === 'none' || btn.id === 'audioVideo' && mode === 'video');
    });
    updateUploadAudio();
  }

  document.getElementById('audioNone')?.addEventListener('click', ()=> setAudioMode('none'));
  document.getElementById('audioVideo')?.addEventListener('click', ()=> setAudioMode('video'));

  // --- Record (canvas stream + audio -> MediaRecorder) ---
  let mediaRecorder = null;
  let recordingChunks = [];
  let isRecording = false;
  let lastRecordedBlob = null;
  let recordAudioContext = null;
  const RECORD_FPS = 30;
  const MAX_RECORD_MS = 10 * 60 * 1000; // 10 min cap
  let recordStartTime = 0;
  let recordMaxTimer = null;

  if(recordBtn){
    recordBtn.addEventListener('click', ()=>{
      if(isRecording){
        if(mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
        mediaRecorder = null;
        if(recordAudioContext){ recordAudioContext.close().catch(()=>{}); recordAudioContext = null; }
        isRecording = false;
        if(recordMaxTimer) clearTimeout(recordMaxTimer);
        recordMaxTimer = null;
        recordBtn.textContent = '● RECORD';
        recordBtn.classList.remove('recording');
        if(recordingIndicator) recordingIndicator.classList.remove('show');
        return;
      }
      const videoStream = canvas.captureStream(RECORD_FPS);
      let stream = videoStream;
      let audioTrack = null;
      if(audioMode === 'video'){
        if(useUpload && uploadVideo.src){
          try{
            const ctx = new (window.AudioContext || window.webkitAudioContext)();
            recordAudioContext = ctx;
            const src = ctx.createMediaElementSource(uploadVideo);
            const dest = ctx.createMediaStreamDestination();
            src.connect(dest);
            src.connect(ctx.destination);
            const tracks = dest.stream.getAudioTracks();
            if(tracks.length) audioTrack = tracks[0];
          }catch(err){ console.warn('[VideoSynth] Upload audio capture failed', err); }
        } else if(cameraStream){
          const tracks = cameraStream.getAudioTracks();
          if(tracks.length) audioTrack = tracks[0];
        }
      }
      if(audioTrack){
        stream = new MediaStream([...videoStream.getVideoTracks(), audioTrack]);
      }
      const hasAudio = !!audioTrack;
      const mime = hasAudio
        ? (MediaRecorder.isTypeSupported('video/webm;codecs=vp9,opus') ? 'video/webm;codecs=vp9,opus' : (MediaRecorder.isTypeSupported('video/webm;codecs=vp8,opus') ? 'video/webm;codecs=vp8,opus' : 'video/webm'))
        : (MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm');
      mediaRecorder = new MediaRecorder(stream, { mimeType: mime, videoBitsPerSecond: 5e6, audioBitsPerSecond: hasAudio ? 128000 : undefined });
      recordingChunks = [];
      mediaRecorder.ondataavailable = e => { if(e.data && e.data.size) recordingChunks.push(e.data); };
      mediaRecorder.onstop = ()=>{
        if(recordAudioContext){ recordAudioContext.close().catch(()=>{}); recordAudioContext = null; }
        if(recordingChunks.length) lastRecordedBlob = new Blob(recordingChunks, { type: mime });
        recordingChunks = [];
        if(downloadBtn){ downloadBtn.disabled = false; downloadBtn.title = 'Download last recording'; }
      };
      mediaRecorder.start(100);
      isRecording = true;
      recordStartTime = performance.now();
      recordBtn.textContent = '■ STOP';
      recordBtn.classList.add('recording');
      if(recordingIndicator) recordingIndicator.classList.add('show');
      recordMaxTimer = setTimeout(()=>{
        if(isRecording && recordBtn) recordBtn.click();
      }, MAX_RECORD_MS);
    });
  }

  if(downloadBtn){
    downloadBtn.disabled = true;
    downloadBtn.addEventListener('click', ()=>{
      if(!lastRecordedBlob){ return; }
      const url = URL.createObjectURL(lastRecordedBlob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'glitchlab-' + new Date().toISOString().slice(0,19).replace(/[-:T]/g,'-') + '.webm';
      a.click();
      URL.revokeObjectURL(url);
    });
  }

  // hidden LFOs
  function updateHidden(){
    const tempo = 0.05 + state.tempo * 1.4;
    const chaosAmt = state.chaos * 0.8;
    const randR = ()=> (0.3 + Math.random()*0.5);
    // Use the knob value as base activity -- if a knob like glitch, pixel, rgb, feedback, hue, palette is >0,
    // Tempo drives rate and Chaos drives depth variation
    const lfoMap = {
      g: state.glitch,
      p: state.pixel > 1 ? (state.pixel-1)/80 : 0,
      r: state.rgb,
      f: state.feedbackAmt,
      h: state.hue,
      pal: state.palette
    };
    for(const k of ['g','p','r','f','h','pal']){
      const activity = Math.min(lfoMap[k] * 2, 1);
      state[k].rate = tempo * randR() * (0.3 + activity * 0.7);
      state[k].depth = activity * (0.2 + 0.6 * chaosAmt);
    }
  }
  setInterval(updateHidden, 250);

  // Helpers
  function flash(el){
    el.classList.add('flash');
    setTimeout(()=>el.classList.remove('flash'),300);
  }

  // Knobs with API (for keyboard performance)
  function makeKnob(id,on,def){
    const el=document.getElementById(id);
    if(!el){
      console.warn('[VideoSynth] Missing knob',id);
      const noop=function(){};
      noop.nudge=function(){};
      noop.get=function(){return 0;};
      noop.dialEl=null;
      noop.knobEl=null;
      return noop;
    }
    let v=def||0;
    const knobEl = el.closest('.knob');
    const apply=n=>{
      v=Math.max(0,Math.min(1,n));
      el.style.transform=`rotate(${(v*270)-135}deg)`;
      try{on(v);}catch(_){}
    };
    let drag=false,sy=0,sv=0;
    el.addEventListener('pointerdown',e=>{
      drag=true; sy=e.clientY; sv=v;
      el.setPointerCapture(e.pointerId);
    });
    window.addEventListener('pointerup',()=>drag=false);
    window.addEventListener('pointermove',e=>{
      if(!drag) return;
      apply(sv+(sy-e.clientY)/200);
    });
    apply(v);
    const api=function(n){ if(typeof n==='number') apply(n); };
    api.nudge=function(dv){ apply(v+dv); };
    api.get=function(){ return v; };
    api.dialEl=el;
    api.knobEl=knobEl;
    return api;
  }

  // ═══════════════════════════════════════════
  // DYNAMIC RAIL + TOGGLE RENDERING
  // ═══════════════════════════════════════════
  let knobKeyMap = {};
  let knobApis = {};
  const activeKnobs = new Set();
  let toggleKeyMap = {};
  let toggleBtns = {};

  function getKnobDef(id){ return KNOB_REGISTRY.find(k=>k.id===id); }
  function getEffDef(id){ return EFFECT_REGISTRY.find(e=>e.id===id); }

  function buildRails(){
    knobKeyMap = {};
    knobApis = {};
    const railL = document.getElementById('railLeft');
    const railR = document.getElementById('railRight');
    if(!railL || !railR) return;
    railL.innerHTML = ''; railR.innerHTML = '';

    function buildSide(container, ids, keys, labels){
      ids.forEach((knobId, i)=>{
        const def = getKnobDef(knobId);
        if(!def) return;
        const dialId = 'knob_'+knobId;
        const div = document.createElement('div');
        div.className = 'knob';
        div.innerHTML = `<div class="dial" id="${dialId}"><div class="cap"></div><div class="marker"></div></div>`
          + `<div class="label">${def.label}<span class="shortcut">${labels[i]||''}</span></div>`;
        container.appendChild(div);
        const api = makeKnob(dialId, v=> { state[def.stateKey] = def.transform(v); }, def.def);
        knobApis[knobId] = api;
        if(keys[i]) knobKeyMap[keys[i]] = api;
      });
    }
    buildSide(railL, activeConfig.left, LEFT_KEYS, LEFT_LABELS);
    buildSide(railR, activeConfig.right, RIGHT_KEYS, RIGHT_LABELS);
  }

  function buildToggles(){
    toggleKeyMap = {};
    toggleBtns = {};
    const row1 = document.getElementById('toggleRow1');
    const row2 = document.getElementById('toggleRow2');
    if(!row1 || !row2) return;
    row1.innerHTML = ''; row2.innerHTML = '';

    function buildRow(container, ids, codes, labels, useShift){
      ids.forEach((effId, i)=>{
        const def = getEffDef(effId);
        if(!def) return;
        const btn = document.createElement('button');
        btn.className = 'toggleBtn';
        btn.innerHTML = `<span class="key">${labels[i]||''}</span>${def.label}`;
        btn.addEventListener('click', ()=>{
          state[def.stateKey] = state[def.stateKey] ? 0 : 1;
          btn.classList.toggle('on', !!state[def.stateKey]);
        });
        if(state[def.stateKey]) btn.classList.add('on');
        container.appendChild(btn);
        toggleBtns[effId] = btn;
        if(codes[i]) toggleKeyMap[(useShift?'S_':'')+codes[i]] = btn;
      });
    }
    buildRow(row1, activeConfig.effectsR1, EFF_CODES_R1, EFF_LABELS_R1, false);
    buildRow(row2, activeConfig.effectsR2, EFF_CODES_R1, EFF_LABELS_R2, true);
  }

  function rebuildUI(){
    buildRails();
    buildToggles();
  }
  rebuildUI();

  // decay slider
  const decayEl=document.getElementById('decayRange');
  if(decayEl) decayEl.addEventListener('input', e=> state.decay=parseFloat(e.target.value));

  // resolution selector
  function updateResUI(){
    ['res720','res1080','res4k'].forEach((id,i)=>{
      const el = document.getElementById(id); if(!el) return;
      const key = ['720p','1080p','4K'][i];
      el.classList.toggle('on', state.internalRes === key);
    });
  }
  document.getElementById('res720')?.addEventListener('click', ()=>{ state.internalRes='720p'; updateResUI(); fitCanvas(); });
  document.getElementById('res1080')?.addEventListener('click', ()=>{ state.internalRes='1080p'; updateResUI(); fitCanvas(); });
  document.getElementById('res4k')?.addEventListener('click', ()=>{ state.internalRes='4K'; updateResUI(); fitCanvas(); });
  updateResUI();

  const chromaticRange = document.getElementById('chromaticRange');
  const vignetteRange = document.getElementById('vignetteRange');
  const filmGrainRange = document.getElementById('filmGrainRange');
  if(chromaticRange) chromaticRange.addEventListener('input', e=> state.chromatic=parseFloat(e.target.value));
  if(vignetteRange) vignetteRange.addEventListener('input', e=> state.vignette=parseFloat(e.target.value));
  if(filmGrainRange) filmGrainRange.addEventListener('input', e=> state.filmGrain=parseFloat(e.target.value));

  // ═══════════════════════════════════════════
  // LIBRARY PANEL
  // ═══════════════════════════════════════════
  (function initLibrary(){
    const libOvl = document.getElementById('libOverlay');
    const libBody = document.getElementById('libBody');
    const tabKnobs = document.getElementById('libTabKnobs');
    const tabEffects = document.getElementById('libTabEffects');
    const libClose = document.getElementById('libClose');
    const libTrigger = document.getElementById('libraryTrigger');
    if(!libOvl || !libBody) return;

    let activeTab = 'knobs';
    let swapTarget = null; // {side:'left'|'right'|'effectsR1'|'effectsR2', idx:number}

    function openLib(){ libOvl.classList.add('open'); renderLib(); }
    function closeLib(){ libOvl.classList.remove('open'); swapTarget=null; }
    if(libTrigger) libTrigger.addEventListener('click', openLib);
    if(libClose) libClose.addEventListener('click', closeLib);
    libOvl.addEventListener('click', e=>{ if(e.target===libOvl) closeLib(); });

    tabKnobs.addEventListener('click', ()=>{ activeTab='knobs'; tabKnobs.classList.add('active'); tabEffects.classList.remove('active'); renderLib(); });
    tabEffects.addEventListener('click', ()=>{ activeTab='effects'; tabEffects.classList.add('active'); tabKnobs.classList.remove('active'); renderLib(); });

    function allActiveKnobs(){ return [...activeConfig.left, ...activeConfig.right]; }
    function allActiveEffects(){ return [...activeConfig.effectsR1, ...activeConfig.effectsR2]; }

    function addResetButton(){
      const resetRow = document.createElement('div');
      resetRow.style.cssText = 'display:flex;justify-content:flex-end;margin-bottom:10px;';
      const resetBtn = document.createElement('button');
      resetBtn.className = 'presetTrigger';
      resetBtn.style.cssText = 'padding:6px 14px;font-size:9px;letter-spacing:.1em;';
      resetBtn.textContent = 'RESET TO DEFAULTS';
      resetBtn.addEventListener('click', ()=>{
        activeConfig = defaultActiveConfig();
        saveActiveConfig();
        swapTarget = null;
        rebuildUI();
        renderLib();
      });
      resetRow.appendChild(resetBtn);
      libBody.appendChild(resetRow);
    }

    function renderLib(){
      libBody.innerHTML = '';
      addResetButton();
      if(activeTab === 'knobs') renderKnobLib();
      else renderEffectLib();
    }

    function renderKnobLib(){
      // slot picker
      const slotsDiv = document.createElement('div'); slotsDiv.className='libSlots';
      slotsDiv.innerHTML = '<div class="libSlotsLabel">YOUR ACTIVE KNOBS (click to pick swap target)</div>';

      function addSlotRow(label, side, ids, keyLabels){
        const rowLabel = document.createElement('div'); rowLabel.className='libSlotRowLabel'; rowLabel.textContent=label;
        const row = document.createElement('div'); row.className='libSlotRow';
        ids.forEach((kid, i)=>{
          const def = getKnobDef(kid);
          const slot = document.createElement('div'); slot.className='libSlot';
          if(swapTarget && swapTarget.side===side && swapTarget.idx===i) slot.classList.add('on');
          slot.innerHTML = `<span class="key">${keyLabels[i]||''}</span>${def?def.label:'?'}`;
          slot.addEventListener('click', ()=>{ swapTarget={side,idx:i}; renderLib(); });
          row.appendChild(slot);
        });
        slotsDiv.appendChild(rowLabel);
        slotsDiv.appendChild(row);
      }
      addSlotRow('LEFT RAIL', 'left', activeConfig.left, LEFT_LABELS);
      addSlotRow('RIGHT RAIL', 'right', activeConfig.right, RIGHT_LABELS);
      libBody.appendChild(slotsDiv);

      if(swapTarget){
        const hint = document.createElement('div');
        hint.style.cssText='text-align:center;color:#0ff;font-size:10px;padding:6px;';
        hint.textContent = 'Now click a knob below to swap it in';
        libBody.appendChild(hint);
      }

      // knob catalog by category
      const cats = {};
      KNOB_REGISTRY.forEach(k=>{ (cats[k.cat]=cats[k.cat]||[]).push(k); });
      const active = allActiveKnobs();
      for(const cat in cats){
        const catLabel = document.createElement('div'); catLabel.className='libCatLabel'; catLabel.textContent=cat;
        const grid = document.createElement('div'); grid.className='libGrid';
        cats[cat].forEach(k=>{
          const card = document.createElement('div'); card.className='libCard';
          if(active.includes(k.id)) card.classList.add('on');
          card.innerHTML = `<strong>${k.label}</strong><small>${k.desc}</small>`;
          card.addEventListener('click', ()=>{
            if(!swapTarget) return;
            activeConfig[swapTarget.side][swapTarget.idx] = k.id;
            saveActiveConfig(); rebuildUI(); renderLib();
          });
          grid.appendChild(card);
        });
        libBody.appendChild(catLabel);
        libBody.appendChild(grid);
      }
    }

    function renderEffectLib(){
      const slotsDiv = document.createElement('div'); slotsDiv.className='libSlots';
      slotsDiv.innerHTML = '<div class="libSlotsLabel">YOUR ACTIVE EFFECTS (click to pick swap target)</div>';

      function addSlotRow(label, side, ids, keyLabels){
        const rowLabel = document.createElement('div'); rowLabel.className='libSlotRowLabel'; rowLabel.textContent=label;
        const row = document.createElement('div'); row.className='libSlotRow';
        ids.forEach((eid, i)=>{
          const def = getEffDef(eid);
          const slot = document.createElement('div'); slot.className='libSlot';
          if(swapTarget && swapTarget.side===side && swapTarget.idx===i) slot.classList.add('on');
          slot.innerHTML = `<span class="key">${keyLabels[i]||''}</span>${def?def.label:'?'}`;
          slot.addEventListener('click', ()=>{ swapTarget={side,idx:i}; renderLib(); });
          row.appendChild(slot);
        });
        slotsDiv.appendChild(rowLabel);
        slotsDiv.appendChild(row);
      }
      addSlotRow('ROW 1', 'effectsR1', activeConfig.effectsR1, EFF_LABELS_R1);
      addSlotRow('ROW 2', 'effectsR2', activeConfig.effectsR2, EFF_LABELS_R2);
      libBody.appendChild(slotsDiv);

      if(swapTarget){
        const hint = document.createElement('div');
        hint.style.cssText='text-align:center;color:#0ff;font-size:10px;padding:6px;';
        hint.textContent = 'Now click an effect below to swap it in';
        libBody.appendChild(hint);
      }

      const cats = {};
      EFFECT_REGISTRY.forEach(e=>{ (cats[e.cat]=cats[e.cat]||[]).push(e); });
      const active = allActiveEffects();
      for(const cat in cats){
        const catLabel = document.createElement('div'); catLabel.className='libCatLabel'; catLabel.textContent=cat;
        const grid = document.createElement('div'); grid.className='libGrid';
        cats[cat].forEach(e=>{
          const card = document.createElement('div'); card.className='libEffectCard';
          if(active.includes(e.id)) card.classList.add('on');
          card.innerHTML = `<strong>${e.label}</strong>`;
          card.addEventListener('click', ()=>{
            if(!swapTarget) return;
            activeConfig[swapTarget.side][swapTarget.idx] = e.id;
            saveActiveConfig(); rebuildUI(); renderLib();
          });
          grid.appendChild(card);
        });
        libBody.appendChild(catLabel);
        libBody.appendChild(grid);
      }
    }
  })();

  // Preset popup wiring
  const overlay = document.getElementById('presetOverlay');
  const presetTrigger = document.getElementById('presetTrigger');
  const presetClose = document.getElementById('presetClose');
  const resetPresetBtn = document.querySelector('.preset[data-preset="reset"]');

  if(presetTrigger && overlay){
    presetTrigger.addEventListener('click',()=> overlay.classList.add('open'));
  }
  if(presetClose && overlay){
    presetClose.addEventListener('click',()=> overlay.classList.remove('open'));
  }
  if(overlay){
    overlay.addEventListener('click',e=>{
      if(e.target===overlay) overlay.classList.remove('open');
    });
  }

  // Skin system: Primary = bg, Secondary = borders, Third = accent. Per-skin defaults, Reset to preset.
  const SKIN_STORAGE = 'glitchlab-skin';
  const SKIN_PRIMARY_STORAGE = 'glitchlab-skin-primary';
  const SKIN_SECONDARY_STORAGE = 'glitchlab-skin-secondary';
  const SKIN_THIRD_STORAGE = 'glitchlab-skin-third';
  const SKIN_DEPTH_STORAGE = 'glitchlab-skin-depth';

  const SKIN_DEFAULTS = {
    default: { primary: '#0e1219', secondary: '#2a3144', third: '#00d4ff' },
    cybersigilism: { primary: '#0a0a0a', secondary: '#1a1a2e', third: '#8b00ff' },
    fantasy: { primary: '#0d0f14', secondary: '#3a2f1f', third: '#d4af37' },
    anime: { primary: '#0f0f17', secondary: '#ff1744', third: '#ffea00' },
    futuristic: { primary: '#050a0f', secondary: '#0a3d2e', third: '#00ff88' },
    renaissance: { primary: '#120e08', secondary: '#8b7340', third: '#c9a84c' }
  };

  function getSkinDefaults(skinId){
    return SKIN_DEFAULTS[skinId] || SKIN_DEFAULTS.default;
  }

  function applySkinColors(primary, secondary, third){
    document.documentElement.style.setProperty('--skin-primary', primary);
    document.documentElement.style.setProperty('--skin-secondary', secondary);
    document.documentElement.style.setProperty('--skin-third', third);
    localStorage.setItem(SKIN_PRIMARY_STORAGE, primary);
    localStorage.setItem(SKIN_SECONDARY_STORAGE, secondary);
    localStorage.setItem(SKIN_THIRD_STORAGE, third);
    const primaryInput = document.getElementById('skinPrimaryColor');
    const thirdInput = document.getElementById('skinThirdColor');
    if(primaryInput) primaryInput.value = primary;
    if(thirdInput) thirdInput.value = third;
  }

  function applySkin(){
    const skinId = localStorage.getItem(SKIN_STORAGE) || 'default';
    if(skinId.startsWith('custom-')) return; // custom skins handled by cseInit
    const savedPrimary = localStorage.getItem(SKIN_PRIMARY_STORAGE);
    const savedSecondary = localStorage.getItem(SKIN_SECONDARY_STORAGE);
    const savedThird = localStorage.getItem(SKIN_THIRD_STORAGE);
    const depth = localStorage.getItem(SKIN_DEPTH_STORAGE) || 'shadows';
    const defaults = getSkinDefaults(skinId);
    const primary = savedPrimary || defaults.primary;
    const secondary = savedSecondary || defaults.secondary;
    const third = savedThird || defaults.third;
    applySkinColors(primary, secondary, third);
    document.body.setAttribute('data-skin-depth', depth);
    const depthEl = document.getElementById('skinDepth');
    if(depthEl) depthEl.value = depth;
    if(skinId === 'default'){
      document.body.removeAttribute('data-skin');
    } else {
      document.body.setAttribute('data-skin', skinId);
    }
    document.querySelectorAll('.skinCard').forEach(card=>{
      card.classList.toggle('active', card.getAttribute('data-skin') === skinId);
    });
  }

  applySkin();

  const skinOverlay = document.getElementById('skinOverlay');
  const skinTrigger = document.getElementById('skinTrigger');
  const skinClose = document.getElementById('skinClose');

  if(skinTrigger && skinOverlay){
    skinTrigger.addEventListener('click', ()=> skinOverlay.classList.add('open'));
  }
  if(skinClose && skinOverlay){
    skinClose.addEventListener('click', ()=> skinOverlay.classList.remove('open'));
  }
  if(skinOverlay){
    skinOverlay.addEventListener('click', e=>{
      if(e.target === skinOverlay) skinOverlay.classList.remove('open');
    });
  }

  document.querySelectorAll('.skinCard').forEach(card=>{
    card.addEventListener('click', ()=>{
      const skinId = card.getAttribute('data-skin') || 'default';
      if(skinId === 'default'){
        document.body.removeAttribute('data-skin');
      } else {
        document.body.setAttribute('data-skin', skinId);
      }
      localStorage.setItem(SKIN_STORAGE, skinId);
      document.querySelectorAll('.skinCard').forEach(c=> c.classList.toggle('active', c.getAttribute('data-skin') === skinId));
      const def = getSkinDefaults(skinId);
      applySkinColors(def.primary, def.secondary, def.third);
    });
  });

  const skinResetColors = document.getElementById('skinResetColors');
  if(skinResetColors){
    skinResetColors.addEventListener('click', ()=>{
      const skinId = document.body.getAttribute('data-skin') || 'default';
      const def = getSkinDefaults(skinId);
      applySkinColors(def.primary, def.secondary, def.third);
    });
  }

  const skinPrimaryColor = document.getElementById('skinPrimaryColor');
  const skinThirdColor = document.getElementById('skinThirdColor');
  if(skinPrimaryColor){
    skinPrimaryColor.addEventListener('input', e=>{
      const v = e.target.value;
      document.documentElement.style.setProperty('--skin-primary', v);
      localStorage.setItem(SKIN_PRIMARY_STORAGE, v);
    });
  }
  if(skinThirdColor){
    skinThirdColor.addEventListener('input', e=>{
      const v = e.target.value;
      document.documentElement.style.setProperty('--skin-third', v);
      localStorage.setItem(SKIN_THIRD_STORAGE, v);
    });
  }

  const skinDepth = document.getElementById('skinDepth');
  if(skinDepth){
    skinDepth.addEventListener('change', ()=>{
      const v = skinDepth.value;
      document.body.setAttribute('data-skin-depth', v);
      localStorage.setItem(SKIN_DEPTH_STORAGE, v);
    });
  }

  // ═══════════════════════════════════════════════════════════════
  // CUSTOM SKIN BUILDER
  // ═══════════════════════════════════════════════════════════════

  const CSE_DB_NAME = 'glitchlab-skins';
  const CSE_STORE = 'custom-skins';
  const CSE_ACTIVE_KEY = 'glitchlab-custom-skin-active';

  const CSE_TEXTURES = {
    none: null,
    grain: `url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='256' height='256' filter='url(%23n)'/%3E%3C/svg%3E")`,
    paper: `url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.4' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='256' height='256' filter='url(%23n)'/%3E%3C/svg%3E")`,
    dither: `url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='1.5' numOctaves='1' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='256' height='256' filter='url(%23n)'/%3E%3C/svg%3E")`,
    canvas: `url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.15' numOctaves='2' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='256' height='256' filter='url(%23n)'/%3E%3C/svg%3E")`,
    static: `url("data:image/svg+xml,%3Csvg viewBox='0 0 256 256' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='2.0' numOctaves='1' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='256' height='256' filter='url(%23n)'/%3E%3C/svg%3E")`,
    crosshatch: `url("data:image/svg+xml,%3Csvg width='16' height='16' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 16L16 0M-2 2L2-2M14 18L18 14' stroke='%23fff' stroke-width='.5' opacity='.5'/%3E%3C/svg%3E")`
  };

  function hexToRgba(hex, a){ const r=parseInt(hex.slice(1,3),16),g=parseInt(hex.slice(3,5),16),b=parseInt(hex.slice(5,7),16); return `rgba(${r},${g},${b},${a})`; }
  function adjustBrightness(hex, amt){ let r=parseInt(hex.slice(1,3),16)+amt,g=parseInt(hex.slice(3,5),16)+amt,b=parseInt(hex.slice(5,7),16)+amt; r=Math.max(0,Math.min(255,r));g=Math.max(0,Math.min(255,g));b=Math.max(0,Math.min(255,b)); return '#'+[r,g,b].map(c=>c.toString(16).padStart(2,'0')).join(''); }

  // --- IndexedDB helpers ---
  function cseOpenDB(){
    return new Promise((resolve, reject)=>{
      const req = indexedDB.open(CSE_DB_NAME, 1);
      req.onupgradeneeded = ()=>{ req.result.createObjectStore(CSE_STORE, {keyPath:'id'}); };
      req.onsuccess = ()=> resolve(req.result);
      req.onerror = ()=> reject(req.error);
    });
  }
  function cseSaveSkin(skin){
    return cseOpenDB().then(db=> new Promise((res,rej)=>{
      const tx = db.transaction(CSE_STORE,'readwrite');
      tx.objectStore(CSE_STORE).put(skin);
      tx.oncomplete = ()=> res();
      tx.onerror = ()=> rej(tx.error);
    }));
  }
  function cseDeleteSkin(id){
    return cseOpenDB().then(db=> new Promise((res,rej)=>{
      const tx = db.transaction(CSE_STORE,'readwrite');
      tx.objectStore(CSE_STORE).delete(id);
      tx.oncomplete = ()=> res();
      tx.onerror = ()=> rej(tx.error);
    }));
  }
  function cseGetAllSkins(){
    return cseOpenDB().then(db=> new Promise((res,rej)=>{
      const tx = db.transaction(CSE_STORE,'readonly');
      const req = tx.objectStore(CSE_STORE).getAll();
      req.onsuccess = ()=> res(req.result);
      req.onerror = ()=> rej(req.error);
    }));
  }
  function cseGetSkin(id){
    return cseOpenDB().then(db=> new Promise((res,rej)=>{
      const tx = db.transaction(CSE_STORE,'readonly');
      const req = tx.objectStore(CSE_STORE).get(id);
      req.onsuccess = ()=> res(req.result);
      req.onerror = ()=> rej(req.error);
    }));
  }

  // --- Editor state ---
  let cseEditing = null;
  let csePngLayers = [];
  let cseSelectedPng = -1;
  let cseKnobDataUrl = null;
  let csePrevSkinState = null;

  const csePanel = document.getElementById('csePanel');
  const cseNameInput = document.getElementById('cseName');
  const csePrimaryInput = document.getElementById('csePrimary');
  const cseAccentInput = document.getElementById('cseAccent');
  const cseSurfaceAlpha = document.getElementById('cseSurfaceAlpha');
  const cseSurfaceAlphaVal = document.getElementById('cseSurfaceAlphaVal');
  const cseTextureType = document.getElementById('cseTextureType');
  const cseTextureOpacity = document.getElementById('cseTextureOpacity');
  const cseTextureOpacityVal = document.getElementById('cseTextureOpacityVal');
  const cseBlendMode = document.getElementById('cseBlendMode');
  const csePngUploadBtn = document.getElementById('csePngUpload');
  const csePngInput = document.getElementById('csePngInput');
  const cseLayerList = document.getElementById('cseLayers');
  const cseSaveBtn = document.getElementById('cseSaveBtn');
  const cseCancelBtn = document.getElementById('cseCancelBtn');
  const cseCloseBtn = document.getElementById('cseClose');
  const cseCreateBtn = document.getElementById('cseCreateBtn');
  const cseKnobUploadBtn = document.getElementById('cseKnobUpload');
  const cseKnobInput = document.getElementById('cseKnobInput');
  const cseKnobPreview = document.getElementById('cseKnobPreview');
  const cseKnobClear = document.getElementById('cseKnobClear');
  const customSkinCardsContainer = document.getElementById('customSkinCards');
  const customSkinBg = document.getElementById('customSkinBg');
  const cseImgLayer = document.getElementById('cseImgLayer');
  const cseTexLayer = document.getElementById('cseTexLayer');
  const cseOutsideLayer = document.getElementById('cseOutsideLayer');

  let cseActiveStyleEl = null;

  // --- Open / Close editor ---
  function cseOpen(existingSkin){
    csePrevSkinState = {
      skinId: localStorage.getItem(SKIN_STORAGE),
      dataSkin: document.body.getAttribute('data-skin'),
      styleEl: cseActiveStyleEl ? cseActiveStyleEl.cloneNode(true) : null
    };

    if(existingSkin){
      cseEditing = existingSkin;
      cseNameInput.value = existingSkin.name || '';
      csePrimaryInput.value = existingSkin.colors.primary;
      cseAccentInput.value = existingSkin.colors.third;
      cseSurfaceAlpha.value = Math.round((existingSkin.colors.surfaceAlpha ?? 0.85) * 100);
      cseTextureType.value = existingSkin.texture.type;
      cseTextureOpacity.value = Math.round(existingSkin.texture.opacity * 100) || 5;
      cseBlendMode.value = existingSkin.texture.blendMode;
      csePngLayers = (existingSkin.pngLayers || []).map(l=>({...l}));
      cseKnobDataUrl = existingSkin.knobImage || null;
    } else {
      cseEditing = null;
      cseNameInput.value = '';
      csePrimaryInput.value = '#0e1219';
      cseAccentInput.value = '#7c5cff';
      cseSurfaceAlpha.value = 85;
      cseTextureType.value = 'none';
      cseTextureOpacity.value = 5;
      cseBlendMode.value = 'overlay';
      csePngLayers = [];
      cseKnobDataUrl = null;
    }
    cseSelectedPng = -1;
    document.body.classList.add('cse-editing');
    document.body.setAttribute('data-skin', 'custom');
    csePanel.classList.add('open');
    if(window._cseResetPanelPos) window._cseResetPanelPos();
    cseLiveUpdate();
    cseUpdateLayerList();
    cseRenderPngs();
    cseUpdateKnobPreview();
  }

  function cseClose(){
    document.body.classList.remove('cse-editing');
    csePanel.classList.remove('open');
    if(window._cseResetPanelPos) window._cseResetPanelPos();
    if(csePrevSkinState){
      if(cseActiveStyleEl) cseActiveStyleEl.remove();
      cseActiveStyleEl = null;
      cseImgLayer.innerHTML = '';
      cseOutsideLayer.innerHTML = '';
      cseTexLayer.style.backgroundImage = 'none';
      cseTexLayer.style.opacity = '0';
      if(csePrevSkinState.dataSkin){
        document.body.setAttribute('data-skin', csePrevSkinState.dataSkin);
      } else {
        document.body.removeAttribute('data-skin');
      }
      if(csePrevSkinState.skinId){
        localStorage.setItem(SKIN_STORAGE, csePrevSkinState.skinId);
        if(csePrevSkinState.skinId.startsWith('custom-')){
          cseApplyCustomSkin(csePrevSkinState.skinId.replace('custom-',''));
        } else {
          applySkin();
        }
      } else {
        applySkin();
      }
    }
    cseEditing = null;
    csePngLayers = [];
    cseSelectedPng = -1;
    cseKnobDataUrl = null;
    csePrevSkinState = null;
  }

  // --- Live update: apply changes to actual app in real-time ---
  function cseLiveUpdate(){
    const primary = csePrimaryInput.value;
    const accent = cseAccentInput.value;
    const alpha = parseInt(cseSurfaceAlpha.value) / 100;
    const surfaceColor = hexToRgba(primary, alpha);
    cseSurfaceAlphaVal.textContent = cseSurfaceAlpha.value + '%';
    cseTextureOpacityVal.textContent = cseTextureOpacity.value + '%';

    applySkinColors(primary, primary, accent);
    document.body.setAttribute('data-skin', 'custom');

    if(cseActiveStyleEl) cseActiveStyleEl.remove();
    cseActiveStyleEl = document.createElement('style');
    cseActiveStyleEl.id = 'cse-active-style';

    const texType = cseTextureType.value;
    const texOpacity = parseInt(cseTextureOpacity.value) / 100;
    const blend = cseBlendMode.value;

    // Texture lives in the cseTexLayer div ON TOP of images
    if(texType !== 'none' && CSE_TEXTURES[texType]){
      cseTexLayer.style.backgroundImage = CSE_TEXTURES[texType];
      cseTexLayer.style.opacity = String(texOpacity);
      cseTexLayer.style.mixBlendMode = blend;
    } else {
      cseTexLayer.style.backgroundImage = 'none';
      cseTexLayer.style.opacity = '0';
    }

    let knobCss = '';
    if(cseKnobDataUrl){
      knobCss = `
        body[data-skin="custom"] .dial{
          background:url("${cseKnobDataUrl}") center/contain no-repeat !important;
          box-shadow:none !important;
        }
        body[data-skin="custom"] .cap{
          background:transparent !important;
          box-shadow:none !important;
        }
      `;
    }

    cseActiveStyleEl.textContent = `
      body[data-skin="custom"]{
        --skin-panel-bg:${surfaceColor};
        --skin-panel-bg-bottom:${surfaceColor};
        --skin-accent:${accent};
        --skin-accent2:${accent};
      }
      body[data-skin="custom"] header,
      body[data-skin="custom"] .rail,
      body[data-skin="custom"] .bottomPanel{
        background:${surfaceColor};
        position:relative;
      }
      body[data-skin="custom"] .stage{
        background:${surfaceColor};
      }
      body[data-skin="custom"] .knob{
        background:${surfaceColor};
      }
      body[data-skin="custom"] .knob.active{
        box-shadow:0 0 14px ${accent}55;
      }
      body[data-skin="custom"] .screen{
        box-shadow:inset 0 0 35px rgba(0,0,0,.9);
      }
      body[data-skin="custom"] .toggleBtn{
        background:${surfaceColor};
      }
      ${knobCss}
    `;
    document.head.appendChild(cseActiveStyleEl);

    document.querySelectorAll('.stage-frame').forEach(f=> f.style.display='none');
  }

  // --- Render PNG images into inside/outside layers ---
  // Reverse iteration: first in array (top of list) appended last → visually on top
  function cseRenderPngs(){
    cseImgLayer.innerHTML = '';
    cseOutsideLayer.innerHTML = '';
    for(let i = csePngLayers.length - 1; i >= 0; i--){
      const layer = csePngLayers[i];
      const img = document.createElement('img');
      img.src = layer.dataUrl;
      img.draggable = false;
      const s = layer.scale || 1;
      const r = layer.rotation || 0;
      img.style.left = (layer.x ?? 50) + '%';
      img.style.top = (layer.y ?? 50) + '%';
      img.style.transform = `translate(-50%,-50%) scale(${s}) rotate(${r}deg)`;
      img.style.maxWidth = '50%';
      img.style.maxHeight = '60%';
      if(i === cseSelectedPng) img.classList.add('selected');
      img.dataset.idx = i;
      const isOutside = layer.mode === 'outside';
      (isOutside ? cseOutsideLayer : cseImgLayer).appendChild(img);
    }
  }

  // --- Layer list UI ---
  function cseUpdateLayerList(){
    cseLayerList.innerHTML = '';
    csePngLayers.forEach((layer, i)=>{
      const mode = layer.mode || 'inside';
      const rot = layer.rotation || 0;
      const div = document.createElement('div');
      div.className = 'cse-layer' + (i === cseSelectedPng ? ' selected' : '');
      div.innerHTML = `
        <img src="${layer.dataUrl}" alt=""/>
        <div class="cse-layer-info">
          <div class="cse-layer-name">${layer.name || 'Image ' + (i+1)}</div>
          <div class="cse-layer-controls">
            <div class="cse-layer-row">
              <label>Size</label>
              <input type="range" min="10" max="500" value="${Math.round((layer.scale||1)*100)}" data-idx="${i}" data-prop="scale"/>
              <span>${(layer.scale||1).toFixed(1)}x</span>
            </div>
            <div class="cse-layer-row">
              <label>Rot</label>
              <input type="range" min="0" max="360" value="${rot}" data-idx="${i}" data-prop="rotation"/>
              <span>${rot}&deg;</span>
            </div>
            <div class="cse-layer-mode">
              <button data-mode="inside" class="${mode==='inside'?'active':''}">Inside</button>
              <button data-mode="outside" class="${mode==='outside'?'active':''}">Outside</button>
            </div>
          </div>
        </div>
        <div class="cse-layer-btns">
          <button class="cse-layer-btn up" data-idx="${i}" title="Move up"${i===0?' disabled':''}>&uarr;</button>
          <button class="cse-layer-btn down" data-idx="${i}" title="Move down"${i===csePngLayers.length-1?' disabled':''}>&darr;</button>
          <button class="cse-layer-btn del" data-idx="${i}" title="Delete">&times;</button>
        </div>
      `;
      div.addEventListener('click', (e)=>{
        if(e.target.closest('.cse-layer-btn') || e.target.closest('.cse-layer-mode') || e.target.tagName === 'INPUT') return;
        cseSelectedPng = i;
        cseUpdateLayerList();
        cseRenderPngs();
      });
      div.querySelectorAll('input[type="range"]').forEach(inp=>{
        inp.addEventListener('input', (e)=>{
          const idx = parseInt(e.target.dataset.idx);
          const prop = e.target.dataset.prop;
          if(prop === 'scale'){
            csePngLayers[idx].scale = parseInt(e.target.value) / 100;
            e.target.nextElementSibling.textContent = csePngLayers[idx].scale.toFixed(1) + 'x';
          } else if(prop === 'rotation'){
            csePngLayers[idx].rotation = parseInt(e.target.value);
            e.target.nextElementSibling.textContent = csePngLayers[idx].rotation + '\u00B0';
          }
          cseRenderPngs();
        });
      });
      div.querySelectorAll('.cse-layer-mode button').forEach(btn=>{
        btn.addEventListener('click', ()=>{
          csePngLayers[i].mode = btn.dataset.mode;
          cseUpdateLayerList();
          cseRenderPngs();
        });
      });
      div.querySelector('.cse-layer-btn.up').addEventListener('click', ()=>{
        if(i === 0) return;
        [csePngLayers[i-1], csePngLayers[i]] = [csePngLayers[i], csePngLayers[i-1]];
        if(cseSelectedPng === i) cseSelectedPng = i-1;
        else if(cseSelectedPng === i-1) cseSelectedPng = i;
        cseUpdateLayerList(); cseRenderPngs();
      });
      div.querySelector('.cse-layer-btn.down').addEventListener('click', ()=>{
        if(i >= csePngLayers.length - 1) return;
        [csePngLayers[i], csePngLayers[i+1]] = [csePngLayers[i+1], csePngLayers[i]];
        if(cseSelectedPng === i) cseSelectedPng = i+1;
        else if(cseSelectedPng === i+1) cseSelectedPng = i;
        cseUpdateLayerList(); cseRenderPngs();
      });
      div.querySelector('.cse-layer-btn.del').addEventListener('click', ()=>{
        csePngLayers.splice(i, 1);
        if(cseSelectedPng >= csePngLayers.length) cseSelectedPng = csePngLayers.length - 1;
        cseUpdateLayerList();
        cseRenderPngs();
      });
      cseLayerList.appendChild(div);
    });
  }

  // --- PNG drag on the live app (both inside and outside layers) ---
  function csePngDragHandler(e){
    const img = e.target.closest('img');
    if(!img || !document.body.classList.contains('cse-editing')) return;
    e.preventDefault();
    const idx = parseInt(img.dataset.idx);
    cseSelectedPng = idx;
    cseUpdateLayerList();
    cseRenderPngs();

    const layer = csePngLayers[idx];
    const container = layer.mode === 'outside' ? cseOutsideLayer : cseImgLayer;
    const imgEl = container.querySelector(`img[data-idx="${idx}"]`);
    if(imgEl) imgEl.classList.add('dragging','selected');

    const rect = customSkinBg.getBoundingClientRect();
    const startX = e.clientX, startY = e.clientY;
    const startPctX = layer.x ?? 50;
    const startPctY = layer.y ?? 50;

    function onMove(ev){
      const dx = ev.clientX - startX, dy = ev.clientY - startY;
      layer.x = Math.max(-20, Math.min(120, startPctX + (dx / rect.width) * 100));
      layer.y = Math.max(-20, Math.min(120, startPctY + (dy / rect.height) * 100));
      const el = container.querySelector(`img[data-idx="${idx}"]`);
      if(el){ el.style.left = layer.x + '%'; el.style.top = layer.y + '%'; }
    }
    function onUp(){
      document.removeEventListener('mousemove', onMove);
      document.removeEventListener('mouseup', onUp);
      const el = container.querySelector(`img[data-idx="${idx}"]`);
      if(el) el.classList.remove('dragging');
    }
    document.addEventListener('mousemove', onMove);
    document.addEventListener('mouseup', onUp);
  }
  cseImgLayer.addEventListener('mousedown', csePngDragHandler);
  cseOutsideLayer.addEventListener('mousedown', csePngDragHandler);

  // --- PNG upload ---
  csePngUploadBtn.addEventListener('click', ()=> csePngInput.click());
  csePngInput.addEventListener('change', ()=>{
    Array.from(csePngInput.files).forEach(file=>{
      const reader = new FileReader();
      reader.onload = (e)=>{
        csePngLayers.push({ dataUrl: e.target.result, name: file.name.replace(/\.[^.]+$/, ''), x: 50, y: 50, scale: 1, rotation: 0, mode: 'inside' });
        cseSelectedPng = csePngLayers.length - 1;
        cseUpdateLayerList();
        cseRenderPngs();
      };
      reader.readAsDataURL(file);
    });
    csePngInput.value = '';
  });

  // --- Custom knob upload ---
  cseKnobUploadBtn.addEventListener('click', ()=> cseKnobInput.click());
  cseKnobInput.addEventListener('change', ()=>{
    const file = cseKnobInput.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (e)=>{
      cseKnobDataUrl = e.target.result;
      cseUpdateKnobPreview();
      cseLiveUpdate();
    };
    reader.readAsDataURL(file);
    cseKnobInput.value = '';
  });
  cseKnobClear.addEventListener('click', ()=>{
    cseKnobDataUrl = null;
    cseUpdateKnobPreview();
    cseLiveUpdate();
  });
  function cseUpdateKnobPreview(){
    if(cseKnobDataUrl){
      cseKnobPreview.style.backgroundImage = `url("${cseKnobDataUrl}")`;
    } else {
      cseKnobPreview.style.backgroundImage = 'none';
    }
  }

  // --- Live preview wiring ---
  [csePrimaryInput, cseAccentInput].forEach(el=> el.addEventListener('input', cseLiveUpdate));
  [cseSurfaceAlpha, cseTextureOpacity].forEach(el=> el.addEventListener('input', cseLiveUpdate));
  [cseTextureType, cseBlendMode].forEach(el=> el.addEventListener('change', cseLiveUpdate));

  // --- Draggable panel ---
  (function(){
    const bar = csePanel.querySelector('.cse-top-bar');
    let dragging = false, startX, startY, startLeft, startTop;
    function resetPanelPos(){
      csePanel.style.left = '50%';
      csePanel.style.top = '50%';
      csePanel.style.transform = 'translate(-50%,-50%)';
    }
    resetPanelPos();
    bar.addEventListener('mousedown', (e)=>{
      if(e.target.tagName === 'BUTTON') return;
      dragging = true;
      const rect = csePanel.getBoundingClientRect();
      csePanel.style.left = rect.left + 'px';
      csePanel.style.top = rect.top + 'px';
      csePanel.style.transform = 'none';
      startX = e.clientX; startY = e.clientY;
      startLeft = rect.left; startTop = rect.top;
      e.preventDefault();
    });
    document.addEventListener('mousemove', (e)=>{
      if(!dragging) return;
      const dx = e.clientX - startX, dy = e.clientY - startY;
      csePanel.style.left = (startLeft + dx) + 'px';
      csePanel.style.top = (startTop + dy) + 'px';
    });
    document.addEventListener('mouseup', ()=>{ dragging = false; });
    window._cseResetPanelPos = resetPanelPos;
  })();

  // --- Save ---
  cseSaveBtn.addEventListener('click', async ()=>{
    const name = cseNameInput.value.trim() || 'Custom Skin';
    const skin = {
      id: cseEditing ? cseEditing.id : crypto.randomUUID(),
      name,
      colors: { primary: csePrimaryInput.value, third: cseAccentInput.value, surfaceAlpha: parseInt(cseSurfaceAlpha.value) / 100 },
      texture: { type: cseTextureType.value, opacity: parseInt(cseTextureOpacity.value) / 100, blendMode: cseBlendMode.value },
      pngLayers: csePngLayers.map(l=>({ dataUrl: l.dataUrl, name: l.name, x: l.x, y: l.y, scale: l.scale, rotation: l.rotation || 0, mode: l.mode || 'inside' })),
      knobImage: cseKnobDataUrl || null,
      createdAt: cseEditing ? cseEditing.createdAt : Date.now()
    };
    await cseSaveSkin(skin);
    csePrevSkinState = null;
    document.body.classList.remove('cse-editing');
    csePanel.classList.remove('open');
    if(window._cseResetPanelPos) window._cseResetPanelPos();
    localStorage.setItem(SKIN_STORAGE, 'custom-' + skin.id);
    localStorage.setItem(CSE_ACTIVE_KEY, skin.id);
    cseEditing = null;
    csePngLayers = [];
    cseSelectedPng = -1;
    await cseLoadCustomCards();
    cseApplyCustomSkin(skin.id);
  });

  // --- Cancel / close ---
  cseCancelBtn.addEventListener('click', cseClose);
  cseCloseBtn.addEventListener('click', cseClose);

  // --- Create button ---
  cseCreateBtn.addEventListener('click', ()=>{
    document.getElementById('skinOverlay')?.classList.remove('open');
    cseOpen(null);
  });

  // --- Apply saved custom skin to live app ---
  function cseApplyCustomSkin(skinId){
    cseGetSkin(skinId).then(skin=>{
      if(!skin) return;
      localStorage.setItem(SKIN_STORAGE, 'custom-' + skin.id);
      localStorage.setItem(CSE_ACTIVE_KEY, skin.id);
      document.body.setAttribute('data-skin', 'custom');

      const alpha = skin.colors.surfaceAlpha ?? 0.85;
      const surfaceColor = hexToRgba(skin.colors.primary, alpha);
      applySkinColors(skin.colors.primary, skin.colors.primary, skin.colors.third);

      if(cseActiveStyleEl) cseActiveStyleEl.remove();
      cseActiveStyleEl = document.createElement('style');
      cseActiveStyleEl.id = 'cse-active-style';

      // Texture in the overlay div on top of images
      if(skin.texture.type !== 'none' && CSE_TEXTURES[skin.texture.type]){
        cseTexLayer.style.backgroundImage = CSE_TEXTURES[skin.texture.type];
        cseTexLayer.style.opacity = String(skin.texture.opacity);
        cseTexLayer.style.mixBlendMode = skin.texture.blendMode;
      } else {
        cseTexLayer.style.backgroundImage = 'none';
        cseTexLayer.style.opacity = '0';
      }

      let knobCss = '';
      if(skin.knobImage){
        knobCss = `
          body[data-skin="custom"] .dial{
            background:url("${skin.knobImage}") center/contain no-repeat !important;
            box-shadow:none !important;
          }
          body[data-skin="custom"] .cap{
            background:transparent !important;
            box-shadow:none !important;
          }
        `;
      }

      cseActiveStyleEl.textContent = `
        body[data-skin="custom"]{
          --skin-panel-bg:${surfaceColor};
          --skin-panel-bg-bottom:${surfaceColor};
          --skin-accent:${skin.colors.third};
          --skin-accent2:${skin.colors.third};
        }
        body[data-skin="custom"] header,
        body[data-skin="custom"] .rail,
        body[data-skin="custom"] .bottomPanel{
          background:${surfaceColor};
          position:relative;
        }
        body[data-skin="custom"] .stage{
          background:${surfaceColor};
        }
        body[data-skin="custom"] .knob{
          background:${surfaceColor};
        }
        body[data-skin="custom"] .knob.active{
          box-shadow:0 0 14px ${skin.colors.third}55;
        }
        body[data-skin="custom"] .screen{
          box-shadow:inset 0 0 35px rgba(0,0,0,.9);
        }
        body[data-skin="custom"] .toggleBtn{
          background:${surfaceColor};
        }
        ${knobCss}
      `;
      document.head.appendChild(cseActiveStyleEl);

      cseImgLayer.innerHTML = '';
      cseOutsideLayer.innerHTML = '';
      if(skin.pngLayers && skin.pngLayers.length){
        for(let i = skin.pngLayers.length - 1; i >= 0; i--){
          const layer = skin.pngLayers[i];
          const img = document.createElement('img');
          img.src = layer.dataUrl;
          img.draggable = false;
          const s = layer.scale || 1;
          const r = layer.rotation || 0;
          img.style.left = (layer.x ?? 50) + '%';
          img.style.top = (layer.y ?? 50) + '%';
          img.style.transform = `translate(-50%,-50%) scale(${s}) rotate(${r}deg)`;
          img.style.maxWidth = '50%';
          img.style.maxHeight = '60%';
          const isOutside = layer.mode === 'outside';
          (isOutside ? cseOutsideLayer : cseImgLayer).appendChild(img);
        }
      }

      document.querySelectorAll('.stage-frame').forEach(f=> f.style.display='none');
      document.querySelectorAll('.skinCard').forEach(c=>{
        c.classList.toggle('active', c.getAttribute('data-skin') === 'custom-' + skin.id);
      });
    });
  }

  function cseRemoveCustomSkin(){
    if(cseActiveStyleEl) cseActiveStyleEl.remove();
    cseActiveStyleEl = null;
    cseImgLayer.innerHTML = '';
    cseOutsideLayer.innerHTML = '';
    cseTexLayer.style.backgroundImage = 'none';
    cseTexLayer.style.opacity = '0';
    localStorage.removeItem(CSE_ACTIVE_KEY);
    document.querySelectorAll('.stage-frame').forEach(f=> f.style.display='');
  }

  // --- Custom skin cards in skin grid ---
  async function cseLoadCustomCards(){
    const skins = await cseGetAllSkins();
    customSkinCardsContainer.innerHTML = '';
    if(!skins.length) return;

    const grid = document.createElement('div');
    grid.style.cssText = 'display:flex;flex-wrap:wrap;gap:8px;margin-top:8px;';

    skins.sort((a,b)=> a.createdAt - b.createdAt);
    skins.forEach(skin=>{
      const card = document.createElement('div');
      card.className = 'skinCard';
      card.setAttribute('data-skin', 'custom-' + skin.id);
      card.innerHTML = `${skin.name}<span class="skinCardDel" data-id="${skin.id}" title="Delete">&times;</span>`;

      card.addEventListener('click', (e)=>{
        if(e.target.classList.contains('skinCardDel')) return;
        document.getElementById('skinOverlay')?.classList.remove('open');
        cseApplyCustomSkin(skin.id);
      });
      card.addEventListener('dblclick', (e)=>{
        e.preventDefault();
        document.getElementById('skinOverlay')?.classList.remove('open');
        cseOpen(skin);
      });
      card.querySelector('.skinCardDel').addEventListener('click', async (e)=>{
        e.stopPropagation();
        await cseDeleteSkin(skin.id);
        if(localStorage.getItem(SKIN_STORAGE) === 'custom-' + skin.id){
          cseRemoveCustomSkin();
          localStorage.setItem(SKIN_STORAGE, 'default');
          applySkin();
        }
        await cseLoadCustomCards();
      });
      grid.appendChild(card);
    });

    const label = document.createElement('div');
    label.style.cssText = 'font-size:9px;letter-spacing:.12em;text-transform:uppercase;color:#8b94a5;margin-top:12px;margin-bottom:4px;';
    label.textContent = 'CUSTOM SKINS (double-click to edit)';
    customSkinCardsContainer.appendChild(label);
    customSkinCardsContainer.appendChild(grid);
  }

  // --- Restore on load ---
  (async function cseInit(){
    await cseLoadCustomCards();
    const storedSkin = localStorage.getItem(SKIN_STORAGE);
    if(storedSkin && storedSkin.startsWith('custom-')){
      cseApplyCustomSkin(storedSkin.replace('custom-', ''));
    }
  })();

  // When selecting a preset skin, clear custom skin state
  document.querySelectorAll('.skinCard:not(.cse-create)').forEach(card=>{
    card.addEventListener('click', ()=>{
      const sid = card.getAttribute('data-skin');
      if(sid && !sid.startsWith('custom-')) cseRemoveCustomSkin();
    });
  });

  // Fullscreen toggle
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  const appRoot = document.querySelector('.app');

  function isFullscreen(){
    return document.fullscreenElement ||
           document.webkitFullscreenElement ||
           document.mozFullScreenElement ||
           document.msFullscreenElement;
  }

  function updateFullscreenUI(){
    if(!fullscreenBtn) return;
    if(isFullscreen()) fullscreenBtn.classList.add('on');
    else fullscreenBtn.classList.remove('on');
  }

  function enterFullscreen(){
    const target = appRoot || document.documentElement;
    if(target.requestFullscreen) target.requestFullscreen();
    else if(target.webkitRequestFullscreen) target.webkitRequestFullscreen();
    else if(target.mozRequestFullScreen) target.mozRequestFullScreen();
    else if(target.msRequestFullscreen) target.msRequestFullscreen();
  }

  function exitFullscreen(){
    if(document.exitFullscreen) document.exitFullscreen();
    else if(document.webkitExitFullscreen) document.webkitExitFullscreen();
    else if(document.mozCancelFullScreen) document.mozCancelFullScreen();
    else if(document.msExitFullscreen) document.msExitFullscreen();
  }

  if(fullscreenBtn){
    fullscreenBtn.addEventListener('click', ()=>{
      if(isFullscreen()) exitFullscreen();
      else enterFullscreen();
    });
  }

  document.addEventListener('fullscreenchange', updateFullscreenUI);
  document.addEventListener('webkitfullscreenchange', updateFullscreenUI);
  document.addEventListener('mozfullscreenchange', updateFullscreenUI);
  document.addEventListener('MSFullscreenChange', updateFullscreenUI);

  // UI hide / show (visual only, keyboard still works)
  const uiHideBtn = document.getElementById('uiHideBtn');
  function updateUIHideUI(){
    if(!uiHideBtn) return;
    if(document.body.classList.contains('ui-hidden')) uiHideBtn.classList.add('on');
    else uiHideBtn.classList.remove('on');
  }
  if(uiHideBtn){
    uiHideBtn.addEventListener('click', ()=>{
      const willHide = !document.body.classList.contains('ui-hidden');
      document.body.classList.toggle('ui-hidden');
      updateUIHideUI();

      // When hiding UI, also go fullscreen; when showing UI, exit fullscreen.
      if(willHide){
        if(!isFullscreen()) enterFullscreen();
      } else {
        if(isFullscreen()) exitFullscreen();
      }
    });
  }

  // Keyboard: knobs + toggles + Esc/Q + reset
  window.addEventListener('keydown', e=>{
    if(e.repeat) return;

    if(e.key === 'Escape'){
      const libOvl = document.getElementById('libOverlay');
      if(libOvl && libOvl.classList.contains('open')){
        libOvl.classList.remove('open'); return;
      }
      const skinOverlayEl = document.getElementById('skinOverlay');
      if(skinOverlayEl && skinOverlayEl.classList.contains('open')){
        skinOverlayEl.classList.remove('open');
        return;
      }
      if(overlay && overlay.classList.contains('open')){
        overlay.classList.remove('open');
        return;
      }
      if(document.body.classList.contains('ui-hidden')){
        document.body.classList.remove('ui-hidden');
        updateUIHideUI();
        if(isFullscreen()) exitFullscreen();
        e.preventDefault();
        return;
      }
    }

    if(e.code === 'KeyQ' && document.body.classList.contains('ui-hidden')){
      document.body.classList.remove('ui-hidden');
      updateUIHideUI();
      if(isFullscreen()) exitFullscreen();
      e.preventDefault();
      return;
    }

    // Arrow keys to nudge active knobs
    if(activeKnobs.size && (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'ArrowLeft' || e.key === 'ArrowRight')){
      const dir = (e.key === 'ArrowUp' || e.key === 'ArrowLeft') ? 1 : -1; // up/left increase, down/right decrease
      const baseStep = e.shiftKey ? 0.03 : 0.01;
      const delta = dir * baseStep;
      activeKnobs.forEach(fn=>{
        if(typeof fn.nudge === 'function') fn.nudge(delta);
      });
      e.preventDefault();
      return;
    }

    // Delete / Backspace = global reset (same as Reset preset)
    if(e.key === 'Delete' || e.key === 'Backspace'){
      applyPreset('reset');
      if(resetPresetBtn) flash(resetPresetBtn);
      e.preventDefault();
      return;
    }

    const knobFn = knobKeyMap[e.code];
    if(knobFn){
      activeKnobs.add(knobFn);
      if(knobFn.knobEl) knobFn.knobEl.classList.add('active');
      if(activeKnobs.size>0) document.body.classList.add('performing');
      e.preventDefault();
      return;
    }

    const toggleKey = (e.shiftKey ? 'S_' : '') + e.code;
    const toggleEl = toggleKeyMap[toggleKey];
    if(toggleEl){
      toggleEl.click();
      e.preventDefault();
      return;
    }
  });

  window.addEventListener('keyup', e=>{
    const knobFn = knobKeyMap[e.code];
    if(!knobFn) return;
    activeKnobs.delete(knobFn);
    if(knobFn.knobEl) knobFn.knobEl.classList.remove('active');
    if(!activeKnobs.size) document.body.classList.remove('performing');
  });

  window.addEventListener('blur', ()=>{
    activeKnobs.forEach(fn=>{
      if(fn.knobEl) fn.knobEl.classList.remove('active');
    });
    activeKnobs.clear();
    document.body.classList.remove('performing');
  });

  // Wheel / trackpad scroll: velocity-sensitive, up = increase
  window.addEventListener('wheel', e=>{
    if(!activeKnobs.size) return;

    const primary = Math.abs(e.deltaY) >= Math.abs(e.deltaX) ? e.deltaY : e.deltaX;
    if(primary === 0) return;

    // Map positive (natural scroll up on Mac) to increase
    const direction = primary > 0 ? 1 : -1;
    const magnitude = Math.min(360, Math.abs(primary));
    const speed = magnitude / 60;
    const baseStep = 0.006;
    const delta = direction * baseStep * (1 + speed * 3);

    activeKnobs.forEach(fn=>{
      if(typeof fn.nudge === 'function') fn.nudge(delta);
    });

    e.preventDefault();
  }, {passive:false});

  let lastPointerX = null;
  let lastPointerY = null;

  // Pointer motion (single-finger mouse/trackpad): up/left increase, down/right decrease
  window.addEventListener('mousemove', e=>{
    if(!activeKnobs.size){
      lastPointerX = e.clientX;
      lastPointerY = e.clientY;
      return;
    }

    if(lastPointerX === null || lastPointerY === null){
      lastPointerX = e.clientX;
      lastPointerY = e.clientY;
      return;
    }

    const dx = e.clientX - lastPointerX;
    const dy = e.clientY - lastPointerY;
    lastPointerX = e.clientX;
    lastPointerY = e.clientY;

    // Use axis with larger motion, but respect direction:
    // vertical: up (dy<0) increase, down decrease
    // horizontal: left (dx<0) increase, right decrease
    const useVertical = Math.abs(dy) >= Math.abs(dx);
    const primary = useVertical ? dy : dx;
    if(primary === 0) return;

    let direction;
    if(useVertical){
      direction = dy < 0 ? 1 : -1;
    } else {
      direction = dx < 0 ? 1 : -1;
    }

    const magnitude = Math.min(80, Math.abs(primary));
    const speed = magnitude / 10;
    const baseStep = 0.004;
    const delta = direction * baseStep * (1 + speed * 1.5);

    activeKnobs.forEach(fn=>{
      if(typeof fn.nudge === 'function') fn.nudge(delta);
    });
  });

  // presets
  function setKnobByName(id, val){
    const api = knobApis[id];
    if(api) api(val);
    // also set state directly for knobs not in active config
    const def = getKnobDef(id);
    if(def) state[def.stateKey] = def.transform(val);
  }
  function syncAllToggleUI(){
    for(const eid in toggleBtns){
      const def = getEffDef(eid);
      if(!def) continue;
      toggleBtns[eid].classList.toggle('on', !!state[def.stateKey]);
    }
  }
  function applyPreset(name){
    if(name==='reset'){
      state=JSON.parse(JSON.stringify(defaults));
      KNOB_REGISTRY.forEach(k=>{ const api=knobApis[k.id]; if(api) api(k.def); });
      EFFECT_REGISTRY.forEach(e=> state[e.stateKey]=0);
      syncAllToggleUI();
      const decaySlider=document.getElementById('decayRange');
      if(decaySlider) decaySlider.value = defaults.decay;
      updateResUI(); fitCanvas();
      if(chromaticRange) chromaticRange.value = state.chromatic;
      if(vignetteRange) vignetteRange.value = state.vignette;
      if(filmGrainRange) filmGrainRange.value = state.filmGrain;
      return;
    }
    const presets = {
      neon:{glitch:0.45,pixel:0.22,rgb:0.8,feedback:0.35,hue:0.55,palette:0.6,sat:0.85,bright:0.55,contrast:0.75,bloom:0.6,swirl:0.6,ripple:0.4,warp:0.2,poster:0.5,tempo:0.35,chaos:0.35,_decay:0.94,_on:['displace','strobe']},
      databend:{glitch:0.9,pixel:0.95,rgb:0.8,feedback:0.7,hue:0.25,palette:0.35,sat:0.8,bright:0.5,contrast:0.7,bloom:0.3,swirl:0.2,ripple:0.8,warp:0.3,poster:0.8,tempo:0.35,chaos:0.35,_decay:0.88,_on:['displace','scan','mirror']},
      vhs:{glitch:0.3,pixel:0.15,rgb:0.5,feedback:0.5,hue:0.12,palette:0.5,sat:0.6,bright:0.52,contrast:0.65,bloom:0.25,swirl:0.05,ripple:0.1,warp:0.12,poster:0.4,tempo:0.35,chaos:0.35,vhsWobble:0.7,_decay:0.92,_on:['displace','scan']},
      monochrome:{glitch:0.1,pixel:0.2,rgb:0.05,feedback:0.2,hue:0.0,palette:0.0,sat:0.0,bright:0.5,contrast:0.9,bloom:0.0,swirl:0.0,ripple:0.0,warp:0.0,poster:0.7,tempo:0.35,chaos:0.35,_decay:0.96,_on:['scan','edge']},
      ocean:{glitch:0.22,pixel:0.14,rgb:0.4,feedback:0.35,hue:0.45,palette:0.75,sat:0.85,bright:0.52,contrast:0.55,bloom:0.35,swirl:0.35,ripple:1.0,warp:0.25,poster:0.45,tempo:0.35,chaos:0.35,_decay:0.95,_on:['displace','slit']},
      cinematic:{glitch:0.05,pixel:0.1,rgb:0.2,feedback:0.1,hue:0.0,palette:0.0,sat:0.7,bright:0.5,contrast:0.6,bloom:0.2,swirl:0.0,ripple:0.0,warp:0.0,poster:0.3,tempo:0.35,chaos:0.35,_decay:0.98,_on:[],_post:{chromatic:0.4,vignette:0.5,filmGrain:0.12}},
    };
    const p = presets[name];
    if(!p) return;
    EFFECT_REGISTRY.forEach(e=> state[e.stateKey]=0);
    if(p._on) p._on.forEach(k=> state[k]=1);
    if(p._decay) state.decay = p._decay;
    for(const k in p){
      if(k.startsWith('_')) continue;
      setKnobByName(k, p[k]);
    }
    if(p._post){
      for(const pk in p._post){
        state[pk]=p._post[pk];
        const el = document.getElementById(pk+'Range');
        if(el) el.value = p._post[pk];
      }
    }
    syncAllToggleUI();
  }

  document.querySelectorAll('.preset').forEach(p=>{
    p.addEventListener('click', ()=>{
      applyPreset(p.dataset.preset);
      if(overlay) overlay.classList.remove('open');
    });
  });

  // --- Auth (Supabase): optional, enable via window.__GLITCHLAB_AUTH__ ---
  const authRow = document.getElementById('authRow');
  const authLoginBtn = document.getElementById('authLoginBtn');
  const authUserEmail = document.getElementById('authUserEmail');
  const authLogoutBtn = document.getElementById('authLogoutBtn');
  const authOverlay = document.getElementById('authOverlay');
  const authEmail = document.getElementById('authEmail');
  const authPassword = document.getElementById('authPassword');
  const authSignIn = document.getElementById('authSignIn');
  const authSignUp = document.getElementById('authSignUp');
  const authOverlayClose = document.getElementById('authOverlayClose');
  const authError = document.getElementById('authError');

  if(AUTH_CONFIG.enabled && AUTH_CONFIG.supabaseUrl && AUTH_CONFIG.supabaseAnonKey && window.supabase){
    const supabase = window.supabase.createClient(AUTH_CONFIG.supabaseUrl, AUTH_CONFIG.supabaseAnonKey);
    if(authRow) authRow.style.display = 'flex';

    function updateAuthUI(session){
      const user = session?.user;
      if(authLoginBtn) authLoginBtn.style.display = user ? 'none' : '';
      if(authUserEmail){ authUserEmail.style.display = user ? 'inline' : 'none'; authUserEmail.textContent = user?.email || ''; }
      if(authLogoutBtn) authLogoutBtn.style.display = user ? '' : 'none';
      if(AUTH_CONFIG.requireAuth && !user && authOverlay) authOverlay.classList.add('open');
      else if(user && authOverlay) authOverlay.classList.remove('open');
    }

    supabase.auth.onAuthStateChange((ev, session)=>{ updateAuthUI(session); });
    supabase.auth.getSession().then(({ data: { session } })=>{ updateAuthUI(session); });

    if(authLoginBtn) authLoginBtn.addEventListener('click', ()=>{ if(authOverlay) authOverlay.classList.add('open'); if(authError) authError.textContent = ''; });
    if(authLogoutBtn) authLogoutBtn.addEventListener('click', ()=>{ supabase.auth.signOut(); });
    if(authOverlayClose) authOverlayClose.addEventListener('click', ()=>{ if(!AUTH_CONFIG.requireAuth && authOverlay) authOverlay.classList.remove('open'); });
    if(authSignIn){
      authSignIn.addEventListener('click', async ()=>{
        const email = authEmail?.value?.trim(), password = authPassword?.value;
        if(!email || !password){ if(authError) authError.textContent = 'Email and password required'; return; }
        if(authError) authError.textContent = '';
        const { data, error } = await supabase.auth.signInWithPassword({ email, password });
        if(error){ if(authError) authError.textContent = error.message; return; }
        if(authOverlay) authOverlay.classList.remove('open');
      });
    }
    if(authSignUp){
      authSignUp.addEventListener('click', async ()=>{
        const email = authEmail?.value?.trim(), password = authPassword?.value;
        if(!email || !password){ if(authError) authError.textContent = 'Email and password required'; return; }
        if(authError) authError.textContent = '';
        const { data, error } = await supabase.auth.signUp({ email, password });
        if(error){ if(authError) authError.textContent = error.message; return; }
        if(authOverlay) authOverlay.classList.remove('open');
      });
    }
  }
})();
</script>
</body>
</html>